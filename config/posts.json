{
  "posts": [
    {
      "content": "## GsonFormat \r\n将json字符串转换成一个Java Bean\r\n\r\n## JsonToKotlin\r\n将json字符串转换成一个Java Bean\r\n\r\n## findViewByMe\r\n快速自动生成findViewById\r\n\r\n## JsonOnlineViewer\r\n在Android Studio中请求、调试接口。 \r\n\r\n## GradleDependencyHelper\r\nmaven gradle 依赖支持自动补全插件。 \r\n\r\n## jimu Mirror\r\n一个可以让你在真实的设备上迅速测试布局的插件。jimu Mirror允许在设备上预览随同编码更新的Android布局。\r\n\r\n## Drawable Importer\r\n添加了一个在不同分辨率导入画板或缩放指定图像到定义分辨率的选项\r\n\r\n## AndroidProguardPlugin\r\n一键生成项目混淆代码插件，值得你安装。 \r\n\r\n## folding-plugin\r\n布局文件分组的插件。 \r\n\r\n## AndroidLocalizationer\r\n可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件。\r\n\r\n## PermissionsDispatcher plugin\r\n自动生成6.0权限的代码。 \r\n\r\n## AndroidPixelDimenGenerator\r\nAndroid Studio自动生成dimen.xml文件插件。\r\n\r\n## adb wifi\r\n使用wifi无线调试你的app，无需root权限。\r\n\r\n# findBugs-IDEA\r\n查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…）\r\n\r\n## Android Parcelable code generator\r\nParcelable是Android实体类的一种实例化方式。 \r\n\r\n## ApkMultiChannelPlugin\r\n这是一个为了方便 Android 多渠道打包的 Android Studio / IDEA 插件\r\n\r\n## lint-cleaner-plugin\r\n移除Android中无用资源\r\n\r\n## Translation\r\n翻译\r\n\r\n## findBugs\r\n查找bug的插件\r\n",
      "data": {
        "title": "Android Studio常用插件",
        "date": "2019-10-10 11:21:56",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "android-studio-chang-yong-cha-jian"
    },
    {
      "content": " 记得无论怎么转载，都要注明“转载”并且说明出处一定要选择【转载】，尊重原创！！\r\n\r\n<!-- more -->\r\n\r\n在浏览器打开文章，右键 -> 检查,或者直接F12看html代码\r\n![](https://ouluqiang.github.io//post-images/1570441106069.png)\r\n\r\n再复制文章内容的代码\r\n![](https://ouluqiang.github.io//post-images/1570441466035.png)\r\n\r\n将html直接粘贴到markdown也是可以的，但是我发现代码块的样式会乱掉，所以可以先将html转换成md，[https://tool.lu/markdown/](https://tool.lu/markdown/)\r\n![](https://ouluqiang.github.io//post-images/1570441613122.png)\r\n\r\n",
      "data": {
        "title": "转载文章",
        "date": "2019-10-07 17:32:45",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": " 记得无论怎么转载，都要注明“转载”并且说明出处一定要选择【转载】，尊重原创！！\r",
      "fileName": "zhuan-zai-wen-zhang"
    },
    {
      "content": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/93757755](https://blog.csdn.net/lyhhj/article/details/93757755)\r\n\r\n<!-- more -->\r\n\r\n1\\. 背景\r\n======\r\n\r\n> 之前已经翻译过了Google官方的CodeLabs上面的教程，教程很详细，代码在Github上也可以找到，本篇文章旨在自己的APP上使用效果及演示Demo，来具体的使用Navigation。并且对其进行源码解析。\r\n\r\n基本相关介绍可以查看我之前翻译的文章，基本就是google翻译了一个大概。\r\n\r\n[一、Android Jetpack\\_Note\\_CodeLabs一Navigation](https://juejin.im/post/5cf37caee51d45777621bb2b)\r\n\r\n2\\. 基本使用\r\n========\r\n\r\n> 虽然在之前的文章中已经很详细的介绍了`Navigation`，但是这里也简单的叙述一下我在项目中的具体使用：\r\n\r\n2.1 Navigation+DrawerLayout+ToolBar\r\n-----------------------------------\r\n\r\n我们可以通过使用`Navigation` 配合`DrawerLayout`侧边栏和`Toolbar`标题来进行工作，不再需要我们去定义点击事件，也不需要我们去管理Fragment做切换，只需要我们做相关的配置和极少量的代码就可以了。\r\n\r\n### 2.1.1 DrawerLayout\r\n\r\n侧边栏的用法和我们之前的使用一样，配置好我们`NavigationView`里面的`_headerLayout_`_、_`_menu_`_即可；_\r\n\r\n> **注意：**这里面的menu有一点和我们之前的不一样，item的id必须要和navigation里面的fragment的id相同，否则点击事件不生效，这里先提一下，下面会详细介绍。\r\n\r\n### 2.1.2 ToolBar和NavHostFragment\r\n\r\n`DrawerLayout`配置好之后，我们再来配置标题栏，之前我们的用法都是在中间加一个存放`Fragment`的容器，有可能是`FrameLayout`、`ViewPager`等，这里面我们需要配置一个`Fragment`，这个`Fragment`的**name**是`androidx.navigation.fragment.NavHostFragment`，这是一个添加到布局中的特殊部件，**NavHostFragment**通过**navGraph**与**navigation**导航编辑器进行关联。具体代码如下：\r\n\r\n    <androidx.drawerlayout.widget.DrawerLayout\r\n                xmlns:tools=\"http://schemas.android.com/tools\"\r\n                android:id=\"@+id/drawer_layout\"\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"match_parent\"\r\n                android:fitsSystemWindows=\"true\"\r\n                tools:openDrawer=\"start\">\r\n            <LinearLayout\r\n                    android:layout_width=\"match_parent\"\r\n                    android:layout_height=\"match_parent\"\r\n                    android:orientation=\"vertical\">\r\n                <com.google.android.material.appbar.AppBarLayout\r\n                        android:layout_height=\"wrap_content\"\r\n                        android:layout_width=\"match_parent\"\r\n                        android:theme=\"@style/AppTheme.AppBarOverlay\">\r\n    \r\n                    <androidx.appcompat.widget.Toolbar\r\n                            android:id=\"@+id/toolbar\"\r\n                            android:layout_width=\"match_parent\"\r\n                            android:layout_height=\"?attr/actionBarSize\"\r\n                            android:background=\"?attr/colorPrimary\"\r\n                            android:theme=\"@style/AppTheme.PopupOverlay\"\r\n                    />\r\n    \r\n                </com.google.android.material.appbar.AppBarLayout>\r\n    \r\n                <fragment\r\n                        android:id=\"@+id/fragment_home\"\r\n                        android:name=\"androidx.navigation.fragment.NavHostFragment\"\r\n                        android:layout_width=\"match_parent\"\r\n                        android:layout_height=\"match_parent\"\r\n                        app:defaultNavHost=\"true\"\r\n                        app:navGraph=\"@navigation/navigation_main\"/>\r\n            </LinearLayout>\r\n    \r\n            <com.google.android.material.navigation.NavigationView\r\n                    app:itemIconTint=\"@color/nav_item_txt\"\r\n                    app:itemTextColor=\"@color/nav_item_txt\"\r\n                    android:id=\"@+id/nav_view\"\r\n                    android:layout_width=\"wrap_content\"\r\n                    android:layout_height=\"match_parent\"\r\n                    android:layout_gravity=\"start\"\r\n                    android:fitsSystemWindows=\"true\"\r\n                    app:headerLayout=\"@layout/nav_header_main\"\r\n                    app:menu=\"@menu/activity_main_drawer\"/>\r\n    \r\n        </androidx.drawerlayout.widget.DrawerLayout>\r\n    \r\n\r\n我们可以看到**NavHostFragment**中有两个属性比较特殊：`app:defaultNavHost`和`app:navGraph=\"@navigation/navigation_main\"`，前者就是是否是默认的其实页面，后者就是我们要设计的Navigation布局文件.\r\n\r\n### 2.1.3 navigation_main.xml\r\n\r\n在`Android Studio`3.2版本以上里面内嵌了`Navigation`的设计面板工具，我们可以在res文件夹下面的`navigation`文件里面对我们的fragment/Activity进行设计。\r\n\r\n![WeChatf84276a636246413fd559699a8c1e759.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk1NTM0NzQ3ODMtNzBlMGI3ODItNDNlYy00YTE3LTkyZTYtZTZkOWZmMDZmOTljLnBuZw#align=left&display=inline&height=152&name=WeChatf84276a636246413fd559699a8c1e759.png&originHeight=202&originWidth=546&size=27542&status=done&width=410)\r\n\r\n打开**Desgin**面板，进入设计模式，在里面我们可以新建我们的目标页面。如果你还没创建过一个\\*\\*Destination，\\*\\*你可以点击`create a destination`创建一个`Fragmengt/Activity`。当然如果你之前已经创建好了的话，在这里你可以直接选择：\r\n\r\n![WeChat224344cdf31a9c4010f08da7cdf8f45e.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk1NTM3MDU4ODQtNDNkYTg1ZGMtNmQ0OC00NmY0LWFmMjktOGRkZDQwMTZhZmVkLnBuZw#align=left&display=inline&height=429&name=WeChat224344cdf31a9c4010f08da7cdf8f45e.png&originHeight=858&originWidth=1196&size=147391&status=done&width=598)\r\n\r\n选择完一个**Destination**之后，在面板中就可以看到了，具体的action、arguments就不介绍了，详细的可以看之前的文章。\r\n\r\n打开**Text**模式的xml我们可以看到我们选择的Fragmengt配置信息，当然你也可以不通过面板设计，也可以直接在xml里进行代码编写。  \r\n`startDestination`是APP默认启动的页面，这里面必须要指定，否则会报错crash。这里我的代码所指默认页面是`HomeFragment`，如下：\r\n\r\n    <navigation xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n                xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n                xmlns:tools=\"http://schemas.android.com/tools\"\r\n                android:id=\"@+id/navigation_main\"\r\n                app:startDestination=\"@+id/homeFragment\"\r\n                tools:ignore=\"UnusedNavigation\">\r\n      \r\n     <fragment android:id=\"@+id/homeFragment\"\r\n                  android:name=\"com.hankkin.jetpack_note.ui.home.HomeFragment\"\r\n                  android:label=\"@string/menu_home\">\r\n            <action android:id=\"@+id/action_navigationFragment_to_webFragment\"\r\n                    app:destination=\"@id/webFragment\"\r\n                    app:enterAnim=\"@anim/slide_in_right\"\r\n                    app:exitAnim=\"@anim/slide_out_left\"\r\n                    app:popEnterAnim=\"@anim/slide_in_left\"\r\n                    app:popExitAnim=\"@anim/slide_out_right\"/>\r\n        </fragment>\r\n    \r\n        <fragment android:id=\"@+id/codeFragment\"\r\n                  android:name=\"com.hankkin.jetpack_note.ui.CodeFragment\"\r\n                  android:label=\"@string/menu_code\"/>\r\n    \r\n\r\n我们可以看到上面的布局代码 默认的起始页面是homeFragment，下面还有一个codeFragment，其实这两个fragment也就是对应着在menu中的两个菜单，同时也对应我们侧边栏中的一个**首页**和一个**代码页，**\r\n\r\n    <item\r\n                    android:id=\"@+id/homeFragment\"\r\n                    android:icon=\"@drawable/ic_menu_home\"\r\n                    android:title=\"@string/menu_home\"/>\r\n            <item\r\n                    android:id=\"@+id/codeFragment\"\r\n                    android:icon=\"@drawable/ic_menu_code\"\r\n                    android:title=\"@string/menu_code\"/>\r\n    \r\n\r\n> 还记得上面说的id要相同吗？就是上面**item的id**要和**navigation_main.xml**中fragment的id相同，否则点击菜单不会切换fragment的。\r\n\r\n配置完上面这些信息之后，怎么将他们绑定起来使用呢？\r\n\r\n### 2.1.4 NavController\r\n\r\n先看下代码：\r\n\r\n    \t\tnavController = Navigation.findNavController(this, R.id.fragment_home)\r\n            appBarConfiguration = AppBarConfiguration(setOf(R.id.homeFragment, R.id.codeFragment), drawerLayout)\r\n            // Set up ActionBar\r\n            setSupportActionBar(mDataBinding.toolbar)\r\n            setupActionBarWithNavController(navController, appBarConfiguration)\r\n            // Set up navigation menu\r\n            mDataBinding.navView.setupWithNavController(navController)\r\n    \r\n\r\n*   我们通过findNavController传入之前定义好的装载fragment的容器id（也就是之前定义的NavHostFragment）找到了Navigation对应的navController；\r\n*   通过配置一个AppBarConfiguration，AppBarConfiguration 里传入了一个id的set集合和drawerlayout，id的集合就是我们在\\*\\*navigation_main.xml \\*\\*定义的fragment id\r\n*   最后通过设置setupActionBarWithNavController、setupWithNavController进行关联绑定\r\n\r\n> 到此，我们的基本配置就结束了，可以看到我们drawerlayout中的首页和代码按钮点击会切换对应的fragment，同时toolbar的汉堡按钮和返回按钮也会自动切换；当然Navigation还可以配合BottomNavigationView使用。\r\n\r\n2.2 BottomNavigationView使用\r\n--------------------------\r\n\r\n### 2.2.1 配置文件\r\n\r\n和上面的步骤类似：也是配置好 navigation.xml布局以及 BottomNavigationView所对应的menu菜单文件  \r\n\r\n### 2.2.2 setupWithNavController\r\n\r\n当然BottomNavigationView也提供了扩展方法setupWithNavController去绑定菜单和fragment，这里使用很简单就不具体介绍了。详情可见[BottomNavSampleActivity](https://github.com/Hankkin/JetPack_Note/blob/master/app/src/main/java/com/hankkin/jetpack_note/ui/navigation/BottomNavSampleActivity.kt)。\r\n\r\n2.3 Action跳转及传餐\r\n---------------\r\n\r\n### 2.3.1 Action跳转\r\n\r\n先看一下navigation的Desgin模式：\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk2MzQ4MzIwNDUtMTZmYzY0ZWItOTI3MS00MTAwLWEyOTMtM2I4MDg5M2UzMWEzLnBuZw#align=left&display=inline&height=348&name=image.png&originHeight=695&originWidth=747&size=159060&status=done&width=374)\r\n\r\n可能你会注意到这些线是什么？没错这就是一个一个的**Action**，当你手动将两个Fragment进行连线后，在xml布局里面会对应生成一个标签，例如：\r\n\r\n    <action android:id=\"@+id/action_dashBoardSampleFragment_to_notificationSampleFragment\"\r\n                    app:destination=\"@id/notificationSampleFragment\"/>\r\n    \r\n\r\n  \r\n它会自动创建好id，id有可能比较长，但是确很清楚，从xtoy的模式，当然如果你不喜欢可以自己改，destination则是我们要跳转到的目标接界面。\r\n\r\naction设置好了之后，我们可以执行下面代码进行跳转：\r\n\r\n    findNavController().navigate(R.id.action_homeSampleFragment_to_dashBoardSampleFragment_action)\r\n    \r\n\r\n### 2.3.2 NavOptions切换动画\r\n\r\n当然fragment之间的切换是支持动画的，NavOptions是一个动画管理类，我们可以设置进入和回退的动画，设置的方式有两种：\r\n\r\n1.  直接在标签中设置动画\r\n\r\n    <action android:id=\"@+id/action_homeSampleFragment_to_dashBoardSampleFragment_action\"\r\n                    app:destination=\"@id/dashBoardSampleFragment\"\r\n                    app:enterAnim=\"@anim/slide_in_right\"\r\n                    app:exitAnim=\"@anim/slide_out_left\"\r\n                    app:popEnterAnim=\"@anim/slide_in_left\"\r\n                    app:popExitAnim=\"@anim/slide_out_right\"/>\r\n    \r\n\r\n2.  通过NavOptions设置动画\r\n\r\n    val options = navOptions {\r\n                anim {\r\n                    enter = R.anim.slide_in_right\r\n                    exit = R.anim.slide_out_left\r\n                    popEnter = R.anim.slide_in_left\r\n                    popExit = R.anim.slide_out_right\r\n                }\r\n            }\r\n            view.findViewById< Button>(R.id.navigate_destination_button)?.setOnClickListener {\r\n                findNavController().navigate(R.id.flow_step_one_dest, null, options)\r\n            }\r\n    \r\n\r\n### 2.3.3 参数传递\r\n\r\nfragment之间的切换参数传递的方法也很简单，之前我们可能要通过宿主Activity或者接口等方法，总之挺麻烦的，下面我们看看通过Navigation控制的Fragment之间怎么传递？\r\n\r\n我们可以在naviagtion布局中使用标签，\r\n\r\n*   name是我们传参的key\r\n*   argType是参数类型\r\n*   defaultValue默认值\r\n*   nullable 是否可空\r\n\r\n    <argument\r\n             android:name=\"deep_args\"\r\n             app:argType=\"\"\r\n             android:defaultValue=\"\"\r\n             app:nullable=\"\"/>\r\n    \r\n\r\n> **注意：**当然type类型也支持我们自定的实体类，但是需要你填写类的全路径，同时你要保证实体类实现了序列化\r\n\r\n我们可以通过把参数传递封装到Bundle中，然后再执行navigate()方法时传递过去，例如：\r\n\r\n    val args = Bundle()\r\n    args.putString(\"link\",\"1\")\r\n    args.putString(\"title\",\"1\")\r\n    it.findNavController().navigate(R.id.webFragment, args)\r\n    \r\n\r\n当然你在接受是也可以通过getArguments().getString(xxxx)这种方式去获取，但是Navigation组件还提供给了我们更简单的方式，当你设置了标签后，通过编译代码，会自动为我们生成一个**XXXFragmentDirections**类，它里面为我们作了参数的封装，而NavController的navigate()方法同时支持direction类型的传递。\r\n\r\n    val direction = HomeFragmentDirections.actionNavigationFragmentToWebFragment(link,title)\r\n    it.findNavController().navigate(direction)\r\n    \r\n\r\n同时在我们的目标页面所对应了一个XXXFragmentArgs，我们可以直接拿到navArgs()从这里我们可以直接拿到参数。\r\n\r\n    private val args: WebFragmentArgs by navArgs()\r\n    \r\n\r\n2.4 Deep Link\r\n-------------\r\n\r\n关于Deep Link 是指跳入应用内的一个功能，我就把它翻译成深层链接了，Navigation提供了这样一个功能，使用起来也很简单：\r\n\r\n                val args = Bundle()\r\n                args.putString(\"deep_args\",et_deep_link.text.toString())\r\n                val deep = findNavController().createDeepLink()\r\n                    .setDestination(R.id.notificationSampleFragment)\r\n                    .setArguments(args)\r\n                    .createPendingIntent()\r\n    \r\n                val notificationManager =\r\n                    context?.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                    notificationManager.createNotificationChannel(\r\n                        NotificationChannel(\r\n                            \"deeplink\", \"Deep Links\", NotificationManager.IMPORTANCE_HIGH)\r\n                    )\r\n                }\r\n                val builder = NotificationCompat.Builder(\r\n                    context!!, \"deeplink\")\r\n                    .setContentTitle(resources.getString(R.string.app_name))\r\n                    .setContentText(\"Navigation 深层链接测试\")\r\n                    .setSmallIcon(R.mipmap.jetpack)\r\n                    .setContentIntent(deep)\r\n                    .setAutoCancel(true)\r\n                notificationManager.notify(0, builder.build())\r\n    \r\n\r\n我们可以创建一个DeepLink，带上参数，通过Notification通知来测试这样的效果，可以直接跳到项目中的该页面。  \r\n具体可查看[SampleNotificationFragment](https://github.com/Hankkin/JetPack_Note/blob/master/app/src/main/java/com/hankkin/jetpack_note/ui/navigation/SampleNotificationFragment.kt)。\r\n\r\n3\\. 源码解析\r\n========\r\n\r\n### 3.1 NavHostFragment\r\n\r\n> 官网上是这样介绍它的：NavHostFragment provides an area within your layout for self-contained navigation to occur. 大致意思就是NavHostFragment在布局中提供了一个区域，用于进行包含导航\r\n\r\n接下来我们看一下它的源码：\r\n\r\n    public class NavHostFragment extends Fragment implements NavHost {\r\n        @CallSuper\r\n        @Override\r\n        public void onAttach(@NonNull Context context) {\r\n            super.onAttach(context);\r\n            if (mDefaultNavHost) {\r\n                requireFragmentManager().beginTransaction()\r\n                        .setPrimaryNavigationFragment(this)\r\n                        .commit();\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n可以看到它就是一个`Fragment`，在`onAttach`生命周期开启事务将它自己设置成了PrimaryFragment了，当然通过`defaultNavHost`条件判断的，这个布尔值看着眼熟吗？没错，就是我们在xml布局中设置的那一个。\r\n\r\n    \t\t\t\t\t<fragment\r\n                        android:id=\"@+id/fragment_home\"\r\n                        android:name=\"androidx.navigation.fragment.NavHostFragment\"\r\n                        android:layout_width=\"match_parent\"\r\n                        android:layout_height=\"match_parent\"\r\n                        app:defaultNavHost=\"true\"\r\n                        app:navGraph=\"@navigation/navigation_main\"/>\r\n    \r\n\r\n接着看它的`onCreate`生命周期\r\n\r\n        @CallSuper\r\n        @Override\r\n        public void onCreate(@Nullable Bundle savedInstanceState) {\r\n            super.onCreate(savedInstanceState);\r\n            final Context context = requireContext();\r\n    \r\n            mNavController = new NavController(context);\r\n            mNavController.getNavigatorProvider().addNavigator(createFragmentNavigator());\r\n    \r\n           \t.......\r\n    \r\n            if (navState != null) {\r\n                // Navigation controller state overrides arguments\r\n                mNavController.restoreState(navState);\r\n            }\r\n            if (mGraphId != 0) {\r\n                // Set from onInflate()\r\n                mNavController.setGraph(mGraphId);\r\n            } else {\r\n                // See if it was set by NavHostFragment.create()\r\n                final Bundle args = getArguments();\r\n                final int graphId = args != null ? args.getInt(KEY_GRAPH_ID) : 0;\r\n                final Bundle startDestinationArgs = args != null\r\n                        ? args.getBundle(KEY_START_DESTINATION_ARGS)\r\n                        : null;\r\n                if (graphId != 0) {\r\n                    mNavController.setGraph(graphId, startDestinationArgs);\r\n                }\r\n            }\r\n        }\r\n    \r\n\r\n我们看到在`onCreate`生命周期中创建了一个`NavController`，并且为这个`NavController`创建了一个`_Navigator_`_添加了进去，_我们跟踪`createFragmentNavigator`，发现它创建了一个`FragmentNavigator`，这个类是做什么的呢？它继承了Navigator，查看注释我们知道它是为每个Navigation设置策略的，也就是说Fragment之间通过导航切换都是由它来操作的，下面会详细介绍的，这里先简单看下。  \r\n接下来我们看到为`NavController`设置了`setGraph()`，也就是我们xml里面定义的`navGraph`，导航布局里面的`Fragment`及`action`跳转等信息。\r\n\r\n还有就是onCreateView、onViewCreated等生命周期方法，基本就是加载布局设置ID的方法了。\r\n\r\n下面我们跟到NavController.setGraph()中看下是怎样将我们设计的fragment添加进去的？\r\n\r\n### 3.2 NavController\r\n\r\n    /**\r\n         * Sets the {@link NavGraph navigation graph} to the specified graph.\r\n         * Any current navigation graph data (including back stack) will be replaced.\r\n         *\r\n         * <p>The graph can be retrieved later via {@link #getGraph()}.</p>\r\n         *\r\n         * @param graph graph to set\r\n         * @see #setGraph(int, Bundle)\r\n         * @see #getGraph\r\n         */\r\n        @CallSuper\r\n        public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) {\r\n            if (mGraph != null) {\r\n                // Pop everything from the old graph off the back stack\r\n                popBackStackInternal(mGraph.getId(), true);\r\n            }\r\n            mGraph = graph;\r\n            onGraphCreated(startDestinationArgs);\r\n        }\r\n    \r\n\r\n我们看如果设置的graph不为null，它执行了popBackStackInternal，看注释的意思为从之前的就的graph栈弹出所有的graph：\r\n\r\n    boolean popBackStackInternal(@IdRes int destinationId, boolean inclusive) {\r\n            .....\r\n            .....\r\n            boolean popped = false;\r\n            for (Navigator navigator : popOperations) {\r\n                if (navigator.popBackStack()) {\r\n                    mBackStack.removeLast();\r\n                    popped = true;\r\n                } else {\r\n                    // The pop did not complete successfully, so stop immediately\r\n                    break;\r\n                }\r\n            }\r\n            return popped;\r\n        }\r\n    \r\n\r\n果真remove掉了之前所有的naviagtor。而这个mBackStack是什么时候添加的navigator的呢？查看源码我们发现：\r\n\r\n    private void navigate(@NonNull NavDestination node, @Nullable Bundle args,\r\n                @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {\r\n            boolean popped = false;\r\n            if (navOptions != null) {\r\n                if (navOptions.getPopUpTo() != -1) {\r\n                    popped = popBackStackInternal(navOptions.getPopUpTo(),\r\n                            navOptions.isPopUpToInclusive());\r\n                }\r\n            }\r\n            Navigator<NavDestination> navigator = mNavigatorProvider.getNavigator(\r\n                    node.getNavigatorName());\r\n            Bundle finalArgs = node.addInDefaultArgs(args);\r\n            NavDestination newDest = navigator.navigate(node, finalArgs,\r\n                    navOptions, navigatorExtras);\r\n            if (newDest != null) {\r\n                // 如果NavGraph不在栈内，先拿到父类Navgarph\r\n                ArrayDeque<NavBackStackEntry> hierarchy = new ArrayDeque<>();\r\n                NavGraph parent = newDest.getParent();\r\n                while (parent != null) {\r\n                    hierarchy.addFirst(new NavBackStackEntry(parent, finalArgs));\r\n                    parent = parent.getParent();\r\n                }\r\n                // 现在遍历后堆栈并查看哪些导航图已经在栈内\r\n                Iterator<NavBackStackEntry> iterator = mBackStack.iterator();\r\n                while (iterator.hasNext() && !hierarchy.isEmpty()) {\r\n                    NavDestination destination = iterator.next().getDestination();\r\n                    if (destination.equals(hierarchy.getFirst().getDestination())) {\r\n                        //destination 如果已经在栈顶，不需要再add了\r\n                        hierarchy.removeFirst();\r\n                    }\r\n                }\r\n                // Add all of the remaining parent NavGraphs that aren't\r\n                // already on the back stack\r\n                mBackStack.addAll(hierarchy);\r\n                //添加新的 destination\r\n                NavBackStackEntry newBackStackEntry = new NavBackStackEntry(newDest, finalArgs);\r\n                mBackStack.add(newBackStackEntry);\r\n            }\r\n            if (popped || newDest != null) {\r\n                dispatchOnDestinationChanged();\r\n            }\r\n        }\r\n    \r\n\r\n还记得这个方法吗？我们一般手动切换Fragment时可以调用这个方法，最后就是跟踪到这里。\r\n\r\n    findNavController().navigate(R.id.bottomNavSampleActivity)\r\n    \r\n\r\n同时，切换目标Fragment到栈顶。我们发现最后`dispatchOnDestinationChanged()`这个方法，分发目标界面切换。有必要去跟一下，你可能会发现意想不到的东西：\r\n\r\n     /**\r\n         * Dispatch changes to all OnDestinationChangedListeners.\r\n         * <p>\r\n         * If the back stack is empty, no events get dispatched.\r\n         *\r\n         * @return If changes were dispatched.\r\n         */\r\n        @SuppressWarnings(\"WeakerAccess\") /* synthetic access */\r\n        boolean dispatchOnDestinationChanged() {\r\n            // We never want to leave NavGraphs on the top of the stack\r\n            //noinspection StatementWithEmptyBody\r\n            while (!mBackStack.isEmpty()\r\n                    && mBackStack.peekLast().getDestination() instanceof NavGraph\r\n                    && popBackStackInternal(mBackStack.peekLast().getDestination().getId(), true)) {\r\n                // Keep popping\r\n            }\r\n            if (!mBackStack.isEmpty()) {\r\n                NavBackStackEntry backStackEntry = mBackStack.peekLast();\r\n                for (OnDestinationChangedListener listener :\r\n                        mOnDestinationChangedListeners) {\r\n                    listener.onDestinationChanged(this, backStackEntry.getDestination(),\r\n                            backStackEntry.getArguments());\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    \r\n\r\n这里面分发了所有实现了`OnDestinationChangedListener`接口的方法，继续跟踪，看看都哪些实现了这个接口呢？\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk2NjQwMDM5NDUtNGY2NWU4MjgtZWRlOC00M2VlLWI4NmItNjVlZmVkYzMwMTFhLnBuZw#align=left&display=inline&height=817&name=image.png&originHeight=817&originWidth=1941&size=315597&status=done&width=1941)\r\n\r\n只有一个类实现了**AbstractAppBarOnDestinationChangedListener**，看一下具体实现：\r\n\r\n    @Override\r\n        public void onDestinationChanged(@NonNull NavController controller,\r\n                @NonNull NavDestination destination, @Nullable Bundle arguments) {\r\n            DrawerLayout drawerLayout = mDrawerLayoutWeakReference != null\r\n                    ? mDrawerLayoutWeakReference.get()\r\n                    : null;\r\n            if (mDrawerLayoutWeakReference != null && drawerLayout == null) {\r\n                controller.removeOnDestinationChangedListener(this);\r\n                return;\r\n            }\r\n            CharSequence label = destination.getLabel();\r\n            if (!TextUtils.isEmpty(label)) {\r\n                ......\r\n                ......\r\n                matcher.appendTail(title);\r\n                //设置title\r\n                setTitle(title);\r\n            }\r\n            boolean isTopLevelDestination = NavigationUI.matchDestinations(destination,\r\n                    mTopLevelDestinations);\r\n            if (drawerLayout == null && isTopLevelDestination) {\r\n                //设置icon\r\n                setNavigationIcon(null, 0);\r\n            } else {\r\n                //设置返回箭头状态\r\n                setActionBarUpIndicator(drawerLayout != null && isTopLevelDestination);\r\n            }\r\n        }\r\n    \r\n\r\n原来如此，到这里就应该清楚了，当我们切换Fragment时，大概流程如下：\r\n\r\n1.  切换目标fragment到栈顶\r\n2.  分发目标Fragment切换状态\r\n3.  设置toolbar的标题、icon状态等\r\n4.  当然setTitle()、setNavigationIcon()等都为抽象方法，具体实现可以看子类里是怎么实现的，具体就不叙述了\r\n\r\n> 到这里，基本的几个核心类以及相关实现我们基本了解了，下面我们看一下基本的流程，首先我们从入口进去，一点点跟进\r\n\r\n### 3.3 Navigation.findNavController(this, R.id.fragment_home)\r\n\r\n我们在最开始会初始化一个NavController：\r\n\r\n    @NonNull\r\n        public static NavController findNavController(@NonNull Activity activity, @IdRes int viewId) {\r\n            View view = ActivityCompat.requireViewById(activity, viewId);\r\n            NavController navController = findViewNavController(view);\r\n            .......\r\n            return navController;\r\n        }\r\n    \r\n    @Nullable\r\n        private static NavController findViewNavController(@NonNull View view) {\r\n            while (view != null) {\r\n                NavController controller = getViewNavController(view);\r\n                .........\r\n            }\r\n            return null;\r\n        }\r\n    \r\n    @SuppressWarnings(\"unchecked\")\r\n        @Nullable\r\n        private static NavController getViewNavController(@NonNull View view) {\r\n            Object tag = view.getTag(R.id.nav_controller_view_tag);\r\n            NavController controller = null;\r\n            if (tag instanceof WeakReference) {\r\n                controller = ((WeakReference<NavController>) tag).get();\r\n            } else if (tag instanceof NavController) {\r\n                controller = (NavController) tag;\r\n            }\r\n            return controller;\r\n        }\r\n    \r\n\r\n查看代码可以看到是通过一个tag值来找到的，那么什么时候设置的呢？还记得3.1里面介绍的`NavHostFragment`的生命周期`onViewCreated`么？\r\n\r\n    @Override\r\n        public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\r\n            super.onViewCreated(view, savedInstanceState);\r\n            .......\r\n            View rootView = view.getParent() != null ? (View) view.getParent() : view;\r\n            Navigation.setViewNavController(rootView, mNavController);\r\n        }\r\n    \r\n\r\n在视图创建的时候调用了`Naviagtion.setViewNavController()`。NavController初始化好了之后，接下来将它和**NavigationView**、**ToolBar**、**BottomNavigationView**、**DrawerLayout**进行绑定：\r\n\r\n### 3.4 setupActionBarWithNavController\r\n\r\n不管是`NavigationView`还是`Bottom``NavigationView`，都会调用这个方法，他是`AppCompatActivity`的一个扩展方法，调用的是NavigationUI这个类：\r\n\r\n    public static void setupActionBarWithNavController(@NonNull AppCompatActivity activity,\r\n                @NonNull NavController navController,\r\n                @NonNull AppBarConfiguration configuration) {\r\n            navController.addOnDestinationChangedListener(\r\n                    new ActionBarOnDestinationChangedListener(activity, configuration));\r\n        }\r\n    \r\n\r\n可以看到它就是调用了目标切换的那个接口，用来实现标题按钮等状态的改变。查看它的方法实现：\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk2NjYyNjY1MjItMDFhOTc2YTEtN2I0Ni00OWMwLTljYzEtNmFlZjZjMjNlN2ZhLnBuZw#align=left&display=inline&height=697&name=image.png&originHeight=1393&originWidth=1151&size=265848&status=done&width=576)\r\n\r\n我们看到它重载了很多方法，包括我们上面提到的**NavigationView**、**ToolBar**、**BottomNavigationView**、**DrawerLayout**。这样就将组件的状态切换绑定起来了，当fragment切换时，上面提到的接口分发，去切换布局按钮等状态。\r\n\r\n### 3.5 navView.setupWithNavController(navController)\r\n\r\n    public static void setupWithNavController(@NonNull final NavigationView navigationView,\r\n                @NonNull final NavController navController) {\r\n            navigationView.setNavigationItemSelectedListener(\r\n                    new NavigationView.OnNavigationItemSelectedListener() {\r\n                        @Override\r\n                        public boolean onNavigationItemSelected(@NonNull MenuItem item) {\r\n                            //目标页面是否被选中\r\n                            boolean handled = onNavDestinationSelected(item, navController);\r\n                            if (handled) {\r\n                                //切换菜单状态、关闭抽屉\r\n                                ViewParent parent = navigationView.getParent();\r\n                                if (parent instanceof DrawerLayout) {\r\n                                    ((DrawerLayout) parent).closeDrawer(navigationView);\r\n                                } else {\r\n                                    BottomSheetBehavior bottomSheetBehavior =\r\n                                            findBottomSheetBehavior(navigationView);\r\n                                    if (bottomSheetBehavior != null) {\r\n                                        bottomSheetBehavior.setState(BottomSheetBehavior.STATE_HIDDEN);\r\n                                    }\r\n                                }\r\n                            }\r\n                            return handled;\r\n                        }\r\n                    });\r\n            final WeakReference<NavigationView> weakReference = new WeakReference<>(navigationView);\r\n            navController.addOnDestinationChangedListener(\r\n                    new NavController.OnDestinationChangedListener() {\r\n                        @Override\r\n                        public void onDestinationChanged(@NonNull NavController controller,\r\n                                @NonNull NavDestination destination, @Nullable Bundle arguments) {\r\n                            NavigationView view = weakReference.get();\r\n                            if (view == null) {\r\n                                navController.removeOnDestinationChangedListener(this);\r\n                                return;\r\n                            }\r\n                            Menu menu = view.getMenu();\r\n                            for (int h = 0, size = menu.size(); h < size; h++) {\r\n                                MenuItem item = menu.getItem(h);\r\n                                item.setChecked(matchDestination(destination, item.getItemId()));\r\n                            }\r\n                        }\r\n                    });\r\n        }\r\n    \r\n\r\n最后就是状态切换了，当点击menu菜单或者目标Fragment切换的时候，改变状态。\r\n\r\n### 3.6 遗留问题\r\n\r\n**遗留：**还记得上面说的那个在设置menu菜单栏的item的ID要和navigation.xml里fragment的ID相同么？至于为什么要这么做，我们看上面的第一段代码：跟踪**onNavDestinationSelected()：**\r\n\r\n    public static boolean onNavDestinationSelected(@NonNull MenuItem item,\r\n                @NonNull NavController navController) {\r\n           \t.......\r\n            .......\r\n            if ((item.getOrder() & Menu.CATEGORY_SECONDARY) == 0) {\r\n                builder.setPopUpTo(findStartDestination(navController.getGraph()).getId(), false);\r\n            }\r\n            NavOptions options = builder.build();\r\n            try {\r\n                //TODO provide proper API instead of using Exceptions as Control-Flow.\r\n                navController.navigate(item.getItemId(), null, options);\r\n                return true;\r\n            } catch (IllegalArgumentException e) {\r\n                return false;\r\n            }\r\n        }\r\n    \r\n\r\n我们看到最后还是调用navigate()方法,并且将MenuItem的ID作为参数传递过去：\r\n\r\n    public void navigate(@IdRes int resId, @Nullable Bundle args, @Nullable NavOptions navOptions,\r\n                @Nullable Navigator.Extras navigatorExtras) {\r\n            NavDestination currentNode = mBackStack.isEmpty()\r\n                    ? mGraph\r\n                    : mBackStack.getLast().getDestination();\r\n            if (currentNode == null) {\r\n                throw new IllegalStateException(\"no current navigation node\");\r\n            }\r\n            @IdRes int destId = resId;\r\n            ......\r\n            ......\r\n            //根据menu id查询目标页面\r\n            NavDestination node = findDestination(destId);\r\n            if (node == null) {\r\n                final String dest = NavDestination.getDisplayName(mContext, destId);\r\n                throw new IllegalArgumentException(\"navigation destination \" + dest\r\n                        + (navAction != null\r\n                        ? \" referenced from action \" + NavDestination.getDisplayName(mContext, resId)\r\n                        : \"\")\r\n                        + \" is unknown to this NavController\");\r\n            }\r\n            navigate(node, combinedArgs, navOptions, navigatorExtras);\r\n        }\r\n    \r\n\r\n`NavDestination node = findDestination(destId)`通过Menu Item的ID查询**NavDestination：**  \r\n**\r\n\r\n    @SuppressWarnings(\"WeakerAccess\") /* synthetic access */\r\n        NavDestination findDestination(@IdRes int destinationId) {\r\n            .......\r\n            return currentGraph.findNode(destinationId);\r\n        }\r\n    \r\n    @Nullable\r\n        final NavDestination findNode(@IdRes int resid, boolean searchParents) {\r\n            NavDestination destination = mNodes.get(resid);\r\n            // Search the parent for the NavDestination if it is not a child of this navigation graph\r\n            // and searchParents is true\r\n            return destination != null\r\n                    ? destination\r\n                    : searchParents && getParent() != null ? getParent().findNode(resid) : null;\r\n        }\r\n    \r\n\r\n而**mNodes**是一个SparseArrayCompat数组，而**NavDestination**中维护了navigation.xml中的每个fragment的相关信息：\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk3MDQ2OTM5NjEtZjc0M2Y0ZTMtNDBhOS00ZWY4LWIwODMtMTFmMWMxZWExZGRlLnBuZw#align=left&display=inline&height=383&name=image.png&originHeight=765&originWidth=1208&size=377825&status=done&width=604)\r\n\r\n在初始化的时候通过`addDestination()`放到数组mNodes中，而mId则就是我们的MenuItem的ID，所以很清楚了吧。\r\n\r\n4\\. 总结\r\n------\r\n\r\n### 4.1 流程\r\n\r\n1.  考虑到我们开始如果直接从**setupWithNavController** 入口进行分析的话，可能不太容易找到怎么创建的graph布局中的fragment，以及**NavHostFragment**到底是什么，所以我们先分析了布局中的**NavHostFragment，**我们发现为什么要在布局中声明了一个**NavHostFragment，**它是用来做什么的，最后发现在它的生命周期中创建了一个NavController，并且添加了FragmentNavigator，同时setGraph了。\r\n2.  紧接着我们通过setGraph进入到了**NavController**类中，通过graph里面设置的初始fragment看到了切换栈内切换Fragment的代码。\r\n3.  在里面我们看到了熟悉的`navigate()`方法，在里面dispatchOnDestinationChanged()吸引了我的注意力，通过查找，发现切换Fragment之后，通过该方法去改变布局的状态，也就是OnDestinationChangedListener接口。\r\n4.  到这里基本的代码实现已经了解的差不多了，然后我回到了入口，通过初始化NavController，调用NavigationUI中的方法绑定**NavigationView**、**ToolBar**、**BottomNavigationView**、**DrawerLayout**等布局，在调用`navigate()`方法后，改变状态，整个流程就走通了。\r\n\r\n> 可能有一些不合理的地方，望大家见谅，但是这是我此次的一个基本流程。\r\n\r\n### 4.2 类图\r\n\r\n[![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk3MjgwNzI4MDEtZTRlMGMxOTUtZTRkMy00ODdjLTk0NjktYjZlZjc0YjU0OGZjLnBuZw#align=left&display=inline&height=560&name=image.png&originHeight=1024&originWidth=1363&size=146731&status=done&width=746)](http://lc-2hxprqvs.cn-n1.lcfile.com/55a8ef5cb455ed676f77/navigation.png)\r\n\r\n### 4.3 分析\r\n\r\n#### 4.3.1 **NavHostFragment**\r\n\r\n我们在Activity的布局里面设置了**NavHostFragment**,同时设置了navGraph布局，经过上面的分析我们知道**NavHostFragment**中新建了NavController,并且创建了用来管理Fragment事务及切换的**FragmentNavigator**，可以简单的把它理解成连接Fragment和NavController的一个桥梁，同时也提供了包含导航的容器布局。\r\n\r\n#### 4.3.2 NavController\r\n\r\nNavContorller是整个导航组件的核心，通过它来加载xml中fragment节点转化成**NavDestination**，并保存在栈内，通过navigate()方法切换栈内NavDestination，以做到fragment的切换操作。同时当fragment切换后，下发**OnDestinationChanged**接口，来改变NavgationView、BottomNavgationView、Menu等相关UI操作。\r\n\r\n#### 4.3.3 NavigationUI\r\n\r\n通过NavgationUI类，为各个View设置接口监听，将View的UI状态和NavController中的切换Fragment做了绑定。\r\n\r\n> 到这里整个Navgation组件的源码分析就结束了，大概的流程已经很清晰了，当然没有做到百分百，比如Deep Link部分，感兴趣的可以自行看一下，可以按照这个思路去真的看一下源码，看完之后你真的会对Navgation组件有更深的理解。当然你也可以参考CodeLabs中的Demo以及文档，也可以看我的Jepack_Note的代码，如有不对的地方，还望指出，谅解.",
      "data": {
        "title": "[转载] 1. Jetpack源码解析---看完你就知道Navigation是什么了？",
        "date": "2019-10-07 14:14:33",
        "tags": [
          "Jetpack",
          "Navigation",
          "转载"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/93757755](https://blog.csdn.net/lyhhj/article/details/93757755)\r",
      "fileName": "jetpack-navigation"
    },
    {
      "content": "### kotlin函数\r\n\r\nmain函数  \r\n\r\n    fun main(args:array<String>){\r\n        \r\n    }\r\n\r\n带参数带返回值\r\n\r\n    fun sum(a:Int,b:Int):Int{\r\n        return a+b\r\n    }\r\n    \r\n表达式做函数体，返回值类型自动推断的函数\r\n\r\n    fun sum(a:Int,b:Int)=a+b\r\n    \r\n函数无返回值\r\n    \r\n    fun sum(a:Int,b:Int){\r\n        println(\"sun is ${a+b}\")\r\n    }\r\n    \r\n变量\r\n\r\nval 只读\r\n   \r\n    val a:Int=1 //立即赋值\r\n    val b=2 //自动推断出int类型\r\n    val c:Int //类型\r\n    c=3  //明确赋值\r\n    \r\nvar 读写\r\n    \r\n    var a=5\r\n    a+=1\r\n    \r\n注释跟java一样\r\n\r\n表达式\r\n\r\n    fun sum(a:Int,b:Int):Int{\r\n        if(a>b){\r\n            return a\r\n        }else{\r\n            return b\r\n        }\r\n    }\r\n    \r\nif作为表达式\r\n\r\n    fun sum(a:Int,b:Int)=if(a>b) a else b\r\n    \r\n可空值 null检测\r\n\r\n变量的值可以为null，必须在声明处的类型后添加?标识该引用可以为空\r\n    \r\nstr的值不是数字返回null\r\n    \r\n    fun parseInt(str:String):Int?{\r\n        \r\n    }\r\n\r\n使用返回可空值的函数\r\n\r\n    fun parseInt(str:String):Int?{\r\n        return str.toIntOrNull()\r\n    }\r\n    \r\n    fun printInt(a:String,b:String){\r\n        val x=parseInt(a)\r\n        val y=parseInt(b)\r\n        \r\n        \r\n        //直接使用x y 可能会报错，因为可能为空\r\n        if(x!=null&&y!=null){\r\n            println(x*y)\r\n        }else{\r\n            println(\"error\")    \r\n        }\r\n        \r\n        //或者检测空值，x y会自动转换成非空值\r\n        if(x==null){\r\n            println(\"error\")\r\n            return\r\n        }\r\n        if(y==null){\r\n            println(\"error\")\r\n            return\r\n        }\r\n        println(x*y)\r\n    }\r\n    \r\n    \r\n使用类型检测及自动类型转换\r\n\r\nis运算符检测一个表达式是否某类型的一个实例，如果一个不可变的局部变量或属性已经判断出为某类型，检测后的分支中可以直接当作该类型使用，不需显示转换：\r\n\r\n    fun getStringLength(obj:Any):Int?{\r\n        if(obj is String){\r\n            return obj.length\r\n        }\r\n        return null\r\n    }\r\n    \r\n或者\r\n\r\n    fun getStringLength(obj:Any):Int?{\r\n            if(obj !is String){\r\n                return null\r\n            }\r\n            //自动转换为 string\r\n            return obj.length\r\n        }\r\n        \r\n    fun getStringLength(obj:Any):Int?{\r\n        if(obj is String&&obj.length>0){\r\n            return obj.length\r\n        }\r\n        return null\r\n    }\r\n    \r\n\r\nfor循环.\r\n\r\n\r\n    val list= listOf<String>(\"a\",\"b\",\"c\")\r\n    \r\n    //直接循环\r\n    for (l in list){\r\n        println(l)\r\n    }\r\n    \r\n    //根据下标找数据  \r\n    for (index in list.indices){\r\n        println(\"index ${list[index]}\")\r\n    }\r\n\r\n    //while循环  \r\n    var i=0\r\n    while (i<list.size){\r\n        println(\"while ${list[i]}\")\r\n        i++\r\n    }\r\n    \r\n\r\nwhen表达式\r\n\r\n类似java的  \r\n\r\n        switch (){\r\n            case 0:\r\n                break;\r\n        }\r\n\r\n    fun getWhen(s:String):String?{\r\n        when(s){\r\n            \"a\"-> return \"a1\"\r\n            \"b\"-> return \"b1\"\r\n            \"c\"-> return \"c1\"\r\n        }\r\n        return null\r\n    }\r\n\r\nrange 使用区间  \r\n\r\n    val x=1\r\n    val y=10\r\n    if (x in 1..y+1){\r\n        println(\"range\")\r\n    }\r\n    \r\n检测某个数字是否在区间内  \r\n\r\n    val list= arrayListOf<String>(\"a\",\"b\",\"c\")\r\n    val i=-1\r\n    if (i !in 0..list.lastIndex){\r\n        println(\"${i}\")\r\n    }\r\n    \r\n    //list.indices 指list 0..list.size-1的长度\r\n    if (list.size !in list.indices){\r\n        println(\"${list.indices}---${list.size}\")\r\n    }\r\n    \r\n    //打印 0-10的数\r\n    //包含10\r\n    for (x in 0..10){\r\n        println(x)\r\n    }\r\n    //不包含10\r\n     for (x in  0 until 10){\r\n        println(x)\r\n    }\r\n\r\n    //0-10中,顺序隔3个打印\r\n    for (x in 0..11 step 3){\r\n        println(x)\r\n    }\r\n\r\n    //倒叙隔4个排序\r\n    for (x in 11 downTo 0 step 4){\r\n        println(x)\r\n    }\r\n    \r\n循环迭代  \r\n\r\n    for (x in list){\r\n        println(x)\r\n    }\r\n    \r\n用in判断集合是否包含实例\r\n\r\n    //如果包含set就进判断，不走后续判断，类似java switch ()\r\n    val set= setOf<String>(\"aa\",\"bb\",\"cc\")\r\n    when{\r\n        \"a\" in set -> println(\"这是 a\")\r\n        \"bb\" in set -> println(\"这是 b\")\r\n        \"cc\" in set -> println(\"这是 c\")\r\n    }\r\n    \r\n用lambada过滤（filter）,映射（map）\r\n  \r\n    list.filter { it.startsWith(\"a\") }\r\n            .sortedBy { it }\r\n            .map { it.toUpperCase() }\r\n            .forEach { println(it) }\r\n\r\n\r\n创建数据类\r\n\r\n    data class UserBean(val uid:Int=0,var username:String?=null,var password:String?=null)\r\n\r\n包含  get ,  set ,   toString , equals , hashCode , copy\r\n\r\n    \r\n函数参数默认值\r\n    \r\n    fun getWhen(s:String=\"\",i:Int=0){}\r\n    \r\n过滤list\r\n\r\n    val list= arrayListOf<Int>(1,2,3,41,5,16,5,3,21,1)\r\n    //val s=list.filter { x-> x > 9 }\r\n    val s=list.filter { it>3}\r\n    for (l in s){\r\n        println(l)\r\n    }\r\n    \r\nString内插\r\n\r\n    println(\"${list.indices}---${list.size}\")\r\n    \r\n类型判断\r\n    \r\n    when(s){\r\n       is UserBean -> return \"a1\"\r\n        \"b\" -> return \"b1\"\r\n       is BaseBean<*> -> return \"c1\"\r\n    }\r\n\r\nmap 遍历map\r\n\r\n    val map= mapOf(\"a\" to \"aa\",\"b\" to \"bb\",\"c\" to \"cc\")\r\n    for ((k,v) in map){\r\n        println(\"${k}-----${v}\")\r\n    }\r\n\r\n    //打印map的value\r\n    println(map[\"a\"])\r\n    //给map赋值\r\n    var map= HashMap<String,String>()\r\n    map[\"a\"]=\"asdfas\"\r\n    println(map[\"a\"])\r\n    \r\n    \r\nlateinit 和 lazy 是 Kotlin 中的两种不同的延迟初始化的实现\r\n\r\n    lateinit 只用于变量 var，而 lazy 只用于常量 val\r\n\r\n创建单例模式\r\n\r\n    //object修改类，为单例模式\r\n    object Bean{}\r\n    \r\n用 ? 修饰代表可以为null\r\n\r\n    val file=File(\"T\").listFiles()\r\n    println(file?.size)\r\n    \r\nkotlin 类型\r\n\r\n    Double\r\n    Float\r\n    Long\r\n    Int\r\n    Short\r\n    Byte\r\n    \r\n    Long类型在后面加L：  123L\r\n    Float类型在后面加F： 123F\r\n    \r\nkotlin 1.1起\r\n使用下划线使常量易读\r\n\r\n    val a=1_000_000\r\n    val b=1_0000_0000L\r\n    val c=1_000.000_001\r\n    \r\n显式转换\r\n\r\n    //a为int,b为long类型,编译不通过需要显式转换\r\n    if (a==b)\r\n    \r\n    if (a==b.toInt()){}\r\n    \r\n    \r\n运算\r\n\r\n    位运算符只用 Int Long:\r\n    \r\n    shl(bits) -有符号左移（java的<<）\r\n    shr(bits) -有符号右移（java的>>）\r\n    ushr(bits) -无符号右移（java的>>>）\r\n    and(bits) -位与\r\n    or(bits) -位或\r\n    xor(bits) -位异或\r\n    inv() -位非\r\n    \r\n字符 char\r\n    \r\n    //char显示转换 int\r\n    val s='1'\r\n    s.toInt()\r\n\r\nBoolean\r\n\r\n    ||    或\r\n    &&    与\r\n    !     非\r\n\r\n数组\r\n    \r\n    Array\r\n    \r\n字符串\r\n    \r\n    //字符串添加转义字符\r\n    val s=\"hello\\nworld\"\r\n\r\n字符串模板\r\n\r\n    // $\r\n     val s=\"hello\\nworld\"\r\n    val sa=\"x= ${s}\"\r\n    println(sa)\r\n\r\nif 表达式\r\n\r\n    if(true){\r\n        \r\n    }elese{\r\n        \r\n    }\r\n\r\nwhen 表达式\r\n\r\n    val s=1\r\n    //when取代了switch操作符\r\n    when(s){\r\n        1 -> println(\"aa\")\r\n        //多个分支放一起，用,分隔\r\n        2,3 -> println(\"bb\")\r\n        //用表达式做条件\r\n        getInt() -> println(\"cc\")\r\n        //检测是否在区间\r\n        in 5..10 -> println(\"dd\")\r\n        //其他分支不满足进else\r\n        else ->{\r\n            println(\"else\")\r\n        }\r\n    }\r\n\r\nfor循环\r\n\r\nwhile , do while\r\n\r\n    while(s>0){\r\n\r\n    }\r\n\r\n    do{\r\n        val y=1\r\n    }while(y!=null)\r\n    \r\n返回和跳转\r\n\r\n    return: 从最直接包围他的函数或匿名函数返回\r\n    break:终止直接包围他的循环\r\n    continue:继续下一次直接包围他的循环\r\n\r\n类\r\n    \r\n    class修饰\r\n    \r\n构造函数\r\n    \r\n    //constructor主构造函数，一个或多个次构造函数  \r\n    //主构造函数有注解或可见性修饰符，不可以省略\r\n    //主构造函数可以省略，主构造函数不能包含任何代码\r\n    class Test constructor(string: String){\r\n\r\n        //初始化块代码，主构造参数可以在init中使用\r\n        init {\r\n\r\n        }\r\n    \r\n    \r\n    class Test(val string: String,age:Int) {\r\n\r\n        //初始化块代码，主构造参数可以在init中使用\r\n        init {\r\n    \r\n        }\r\n    \r\n        //次级构造函数,次级构造函数委托给主构造函数需要添加this\r\n        constructor(s: String):this(s,0)\r\n        }\r\n    }\r\n\r\n创建类的实例\r\n\r\n    //调用构造函数，kotlin没有new\r\n    val text=Test(\"a\",0)\r\n    \r\n继承\r\n    \r\n    覆盖函数\r\n    覆盖属性\r\n    覆盖规则\r\n    下次再学    \r\n    \r\n    \r\n抽象类\r\n    \r\n    abstract修饰\r\n    \r\n伴生对象\r\n\r\n\r\n属性和字段\r\n\r\n    属性用var是可变，val是只读\r\n    \r\n    class Test(var string: String?=null,var age:Int?=0) \r\n    \r\n    //用其中某个属性，用名称引用他\r\n    val text=Test()\r\n    text.age\r\n    \r\nget set\r\n\r\n幕后字段， 幕后属性，编译器常量，惰性初始化属性，覆盖属性，委托属性\r\n\r\n\r\n接口\r\n\r\n    用interface修饰\r\n    一个类或对象可以实现一个或多个接口\r\n\r\n接口中的属性\r\n解决覆盖冲突\r\n\r\n    interface A{\r\n        fun getA(){\r\n            println(\"a\")\r\n        }\r\n    }\r\n    \r\n    interface B{\r\n        fun getA(){\r\n            println(\"ba\")\r\n        }\r\n        fun getB(){\r\n            println(\"bb\")\r\n        }\r\n    }\r\n    \r\n    class C:A,B{\r\n        override fun getA() {\r\n            //TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\r\n            //指定实现哪个父类的接口\r\n            super<A>.getA()\r\n            super<B>.getA()\r\n        }\r\n    \r\n        override fun getB() {\r\n            super.getB()\r\n        }\r\n    \r\n    }\r\n\r\n可见性修饰符 \r\n    \r\n    默认是public\r\n    prublic 声明随处可见\r\n    private 声明的文件内可见，类内部可见\r\n    protected 不适用于顶层声明，和private一样+在子类中可见\r\n    internal 相同模块随处可见\r\n    \r\n构造函数\r\n\r\n    //指定类的主构造函数的可见性，必须添加显示的 constrector\r\n    \r\n    class Test private constructor(var string: String?=null,var age:Int?=0) \r\n\r\n默认所有构造函数是public\r\n\r\n局部声明\r\n\r\n    局部变量，函数和类不能有可见性修饰符\r\n\r\n模块\r\n\r\n    可见性修饰符 internal 只在相同模块内可见，一个模块是编译在一起的一套kotlin文件\r\n    一个idea模块\r\n    一个maven或者gradle项目\r\n    一次<kotlinc>Ant人物执行所编译的一套文件\r\n\r\n扩展\r\n\r\n扩展函数\r\n\r\n扩展是静态解析  \r\n    \r\n    （有空在学吧）\r\n\r\n可空接收者\r\n\r\n扩展属性\r\n\r\n伴生对象的扩展\r\n\r\n扩展的作用\r\n\r\n扩展声明为成员\r\n\r\n动机\r\n\r\n    下次学\r\n    \r\n数据类\r\n\r\n生成的类含有一个无参的构造函数，所有的属性必须指定默认值\r\n\r\n    数据类标记为 data\r\n    data class Test (var string: String?=null,var age:Int?=0) \r\n    \r\n复制    \r\n\r\n复制一个对象改变一些属性，保持其他属性不变\r\n    \r\n    var text=Test()\r\n    text.string=\"as\"\r\n    text.age=11\r\n    text=text.copy(age = 14)\r\n    println(text.toString())\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "kotlin基础",
        "date": "2019-09-27 13:17:32",
        "tags": [
          "kotlin"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "kotlin-ji-chu"
    },
    {
      "content": "# svn,git下载地址  \r\n```\r\n链接：https://pan.baidu.com/s/1C6hn1S-hBzdduEoIm7-4XA \r\n提取码：xktl \r\n```\r\n\r\n# SVN\r\n## svn安装需注意安装 command line功能\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568588046.png)\r\n\r\n\r\n在studio的File > Settings > Version Control > Subversion 添加svn路径\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568609300.png)\r\n\r\n\r\n\r\n# GIT\r\n在studio的File > Settings > Version Control > Git 添加git路径，Test测试git版本\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568633842.png)\r\n\r\n\r\nGitHub直接输入账号密码即可\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568657529.png)\r\n\r\n\r\n## androidstudio 看不到svn的工具小图标\r\n\r\n先看androidstudio是否安装svn\r\nFile > Settings > Plugins 搜索Subversion Integration\r\n\r\n如果有Subversion Integration 则安装好svn工具；如果没有安装，则进行安装。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568783281.png)\r\n\r\n\r\n再选择Subversion即可",
      "data": {
        "title": "Android Studio 配置SVN，GIT",
        "date": "2019-09-24 17:56:27",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "android-studio-pei-zhi-svngit"
    },
    {
      "content": "## 1.设置编辑界面和代码主题\r\n\r\nFile > Settings > Appearance & Behavior > Appearance > Theme\"，默认可以选择Light和Darcula，分别为白色和黑色主题，选择之后点击Apply应用。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570829889.png)\r\n\r\n\r\n## 2.修改字体大小和字体样式\r\nFile > Settings > Editor > Color Scheme > Color Scheme Font，先选择一个Scheme主题，打勾设置size然后Apply就好了。在Font下可以选择各种字体。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570855113.png)\r\n\r\n\r\n## 3.设置文件注释模板\r\nFile > Settings > Editor > File and Code Templates，切换到Includes下，在File Header里面设置注释模板。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570879010.png)\r\n\r\n\r\n## 4.默认文件编码\r\n\r\nFile > Settings > Editor > File Encodings。建议将 IDE Encoding 、 Project Encoding 、 Properties Fiels 都设置成统一的UTB-8编码。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570937484.png)\r\n\r\n\r\n## 5.显示行号\r\nFile | Settings | Editor | General | Appearance，勾选show line numbers\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570972769.png)\r\n\r\n\r\n## 6.自动导入\r\nFile > Settings > Editor > General > Auto Import,修改不区分大小写提示，勾选导包和删除无用包\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570998987.png)\r\n\r\n\r\n## 鼠标悬停显示方法说明\r\nFile > Settings > Editor > General\r\n可修改悬停多久，才显示方法说明(单位：毫秒)。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569571044992.png)\r\n\r\n\r\n\r\n## 删除的类的历史记录，与未修改前的类对比\r\n\r\n![](https://ouluqiang.github.io//post-images/1569572112977.png)\r\n\r\n\r\n## 导出，导入studio设置属性\r\nFile > Export Settings 导出设置\r\n\r\n![](https://ouluqiang.github.io//post-images/1569572137353.png)\r\n\r\n\r\nFile > Import Settings 导入设置\r\n\r\n![](https://ouluqiang.github.io//post-images/1569572165039.png)\r\n",
      "data": {
        "title": "Android Studio常用设置",
        "date": "2019-09-24 17:19:41",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "android-studio-chang-yong-she-zhi"
    },
    {
      "content": "# 下载\r\n\r\n[jdk下载地址](https://www.oracle.com/technetwork/java/javase/downloads/index.html)\r\n\r\njdk下载  \r\n```\r\n链接：https://pan.baidu.com/s/1AVshFeP9ZkT05xk_FIINag \r\n提取码：t8ci \r\n```\r\n\r\n\r\n[Android studio sdk 下载地址](http://www.android-studio.org/index.php)\r\n\r\n## jdk12\r\n\r\n安装JDK11或以上版本，安装过程中没有提示安装JRE，进入JDK安装路径下 shift+右键 在此处打开命令窗口\r\n\r\n  输入  \r\n  ```\r\n   bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre   \r\n  ```\r\n  执行完成就会生成JRE\r\n  \r\n![](https://ouluqiang.github.io//post-images/1569573855494.png)\r\n\r\n\r\n## jdk8\r\n正常安装\r\n\r\n## 环境变量配置\r\n\r\n我的电脑右键，点击属性，点击高级系统设置，点击环境变量\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573876482.png)\r\n\r\n\r\n新建系统变量，变量名写 JAVA_HOME 变量值 填写你JDK安装的路径\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573893452.png)\r\n\r\n\r\n双击系统变量path编辑变量值 %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573915023.png)\r\n\r\n\r\n在系统变量中新建 classpath 变量名，变量值为  %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573938408.png)\r\n\r\n\r\nwin+R运行输入cmd，输入java -version查看JDK版本和JVM信息\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573946973.png)\r\n\r\n\r\n\r\n# sdk\r\n\r\n新建系统变量ANDROID_HOME，变量值D:\\xx\\sdk（以你安装目录为准,确认里面有tools和add-ons等多个文件夹）\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573974734.png)\r\n\r\n\r\n在系统变量PATH后面加上变量值;%ANDROID_HOME%\\platform-tools;\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573987528.png)\r\n\r\n\r\nwin+R运行输入cmd，输入adb 查看\r\n\r\n![](https://ouluqiang.github.io//post-images/1569574016688.png)\r\n",
      "data": {
        "title": "jdk sdk环境配置 Android下载",
        "date": "2019-09-24 17:16:07",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jdk-sdk-huan-jing-pei-zhi-android-xia-zai"
    },
    {
      "content": "## type封装获取泛型的实际类型\r\n    \r\n> 通过getGenericSuperclass方法可以获取当前对象的直接超类的 Type\r\n    \r\ngetClass().getGenericSuperclass()返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type  \r\n然后将其转换ParameterizedType。。  \r\ngetActualTypeArguments()返回表示此类型实际类型参数的 Type 对象的数组。  \r\n[0]就是这个数组中第一个了。。简而言之就是获得超类的泛型参数的实际类型。。\r\n```\r\n        Type genericSuperclass = getClass().getGenericSuperclass();\r\n        if (genericSuperclass instanceof ParameterizedType) {\r\n            this.type = ((ParameterizedType) genericSuperclass).getActualTypeArguments()[0];\r\n        } else {\r\n            this.type = Object.class; \r\n            // 基本不会走这个判断\r\n        }\r\n```     \r\n        \r\n        \r\n## 解决 gson反序列化自动将int类型转化成double类型\r\n```\r\n    private static Gson gson=new GsonBuilder().\r\n        registerTypeAdapter(Double.class, new JsonSerializer<Double>() {\r\n\r\n            @Override\r\n            public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) {\r\n                if (src == src.longValue())\r\n                    return new JsonPrimitive(src.longValue());\r\n                return new JsonPrimitive(src);\r\n            }\r\n        }).create();\r\n```",
      "data": {
        "title": "gson type封装泛型",
        "date": "2019-09-24 16:33:44",
        "tags": [
          "Android",
          "gson"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gson-type-feng-zhuang-fan-xing"
    },
    {
      "content": "## 创建分支\r\n在GitHub的博客项目中新建一个分支\r\n\r\n![](https://ouluqiang.github.io//post-images/1569311927040.jpg)\r\n\r\n克隆项目到本地  \r\n```\r\ngit clone https://github.com/xxx/xxx.github.io.git\r\n```\r\n\r\n## 切换分支\r\n\r\n到本地项目中打开Git Bash, 切换到项目分支，查看分支，用 git checkout XXX 切换分支\r\n```\r\n# 列出所有本地分支\r\n$ git branch\r\n\r\n# 列出所有远程分支\r\n$ git branch -r\r\n\r\n# 列出所有本地分支和远程分支\r\n$ git branch -a\r\n\r\n# 切换到指定分支，并更新工作区\r\n$ git checkout [branch-name]\r\n```\r\n![](https://ouluqiang.github.io//post-images/1569311864422.jpg)\r\n\r\n\r\n把源文件复制到分支项目,再打开Git Bash 提交代码\r\n![](https://ouluqiang.github.io//post-images/1569311872576.jpg)\r\n\r\n\r\n```\r\n# 添加当前目录的所有文件到暂存区\r\n$ git add .\r\n\r\n# 提交暂存区到仓库区\r\n$ git commit -m ‘修改说明，随便写’\r\n\r\n# 提交到远程仓库\r\ngit push\r\n```\r\n\r\n提交成功\r\n![](https://ouluqiang.github.io//post-images/1569311915447.jpg)\r\n\r\n\r\n但是提交完会因为提交的源文件有token，GitHub会给你发邮件token泄漏，将原先生成的token移除，原先的token已经失效了，你需要重新申请token,在Gridea的配置修改token,后续如果要提交源文件有1种方法就是不提交有token的文件，也就是源文件/config/setting.json，不提交这个文件就即可\r\n\r\n\r\n<!-- ## 生成ssh-key的私钥和公钥\r\n生成key,看C盘用户目录SSH\r\n\r\n```\r\nssh-keygen -t rsa      //一路回车下来\r\n```\r\n![](https://ouluqiang.github.io//post-images/1569314857492.jpg)\r\n\r\n测试是否能连接上GitHub服务器\r\n```\r\nssh -T git@github.com\r\n```\r\n输出是.........\r\nPermission denied (publickey).\r\n需要将上面生成的public key(id_rsa.pub文件内容)拷贝到github服务器的SSH Keys中，\r\n再.ssh目录下打开终端输入下面代码查看内容，或者直接记事本打开查看\r\n\r\n```\r\ncat id_rsa.pub\r\n```\r\n\r\n![](https://ouluqiang.github.io//post-images/1569315446419.jpg)\r\n\r\n头像 > settings > ssh\r\n![](https://ouluqiang.github.io//post-images/1569315521381.jpg)\r\n\r\n再测试下是否连接GitHub服务器 ssh -T git@github.com 能显示GitHub用户名就表示连接成功\r\n![](https://ouluqiang.github.io//post-images/1569315793106.jpg) -->\r\n",
      "data": {
        "title": "Gridea保存源文件",
        "date": "2019-09-24 15:55:55",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gridea-bao-cun-yuan-wen-jian"
    },
    {
      "content": "Android常用的开发工具\r\n<!-- more -->\r\n\r\n## Android stido，sdk，jdk\r\n[jdk下载地址](https://www.oracle.com/technetwork/java/javase/downloads/index.html)\r\n\r\njdk下载  \r\n```\r\n链接：https://pan.baidu.com/s/1AVshFeP9ZkT05xk_FIINag \r\n提取码：t8ci \r\n```\r\n\r\n\r\n[Android studio sdk 下载地址](http://www.android-studio.org/index.php)\r\n\r\n[Android studio sdk 下载地址](https://developer.android.google.cn/studio)\r\n\r\n## svn,git下载地址\r\n[git下载](https://git-scm.com/downloads)\r\n\r\n```\r\n链接：https://pan.baidu.com/s/1C6hn1S-hBzdduEoIm7-4XA \r\n提取码：xktl \r\n```\r\n\r\n## 抓包工具charles学习版\r\n```\r\n链接：https://pan.baidu.com/s/1aDRIDVu9y66niOZOnPcMDQ \r\n提取码：sj13 \r\n```\r\n\r\n## sqlite数据库工具\r\n```\r\n链接：https://pan.baidu.com/s/1I_w-rARDcKocKBXGOMbJdg \r\n提取码：trl1\r\n```\r\n\r\n## 颜色获取\r\n```\r\n链接：https://pan.baidu.com/s/1-sLi9-PVYksCiE-RHSXquw \r\n提取码：tyrw \r\n```\r\n\r\n## 获取SHA1值\r\n```\r\n链接：https://pan.baidu.com/s/15AvGDv-WjzU7jvLhJeLvhg \r\n提取码：081p \r\n```\r\n\r\n\r\n# idea 学习版\r\nhttp://idea.toocruel.net",
      "data": {
        "title": "常用开发工具",
        "date": "2019-09-24 13:22:26",
        "tags": [
          "工具"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "Android常用的开发工具\r",
      "fileName": "chang-yong-kai-fa-gong-ju"
    },
    {
      "content": "charles基本设置使用\r\n\r\n<!-- more -->\r\n\r\n\r\n## 抓包工具charles学习版\r\n```\r\n链接：https://pan.baidu.com/s/1aDRIDVu9y66niOZOnPcMDQ \r\n提取码：sj13 \r\n```\r\n\r\n## http抓包\r\n代理 > 代理设置中设置端口号 8888 ,勾选启用HTTP代理\r\n![代理设置](https://ouluqiang.github.io//post-images/1569304039210.jpg)\r\n\r\n![端口](https://ouluqiang.github.io//post-images/1569303949066.jpg)\r\n\r\n帮助 > 本地ip 查看电脑ip\r\n![帮助](https://ouluqiang.github.io//post-images/1569304145156.jpg)\r\n\r\n![ip](https://ouluqiang.github.io//post-images/1569304186481.jpg)\r\n\r\n手机和电脑在一个网段(连接同一个路由器)，在手机网络设置里面填写代理服务地址信息\r\n电脑ip ,  端口号\r\n\r\n![代理](https://ouluqiang.github.io//post-images/1569304740083.jpg)\r\n\r\n在使用手机进行网络请求时，charles会有一个提示，允许即可\r\n\r\n## https抓包\r\nhttps需要安装证书，注意电脑安装证书需要安装到受信任的颁发机构\r\n\r\n![证书](https://ouluqiang.github.io//post-images/1569305139356.jpg)\r\n\r\n![安装证书](https://ouluqiang.github.io//post-images/1569305350226.jpg)\r\n\r\n手机也需要安装证书，在浏览器下载证书,如果不识别，不能安装，建议用谷歌浏览器app下载安装\r\n```\r\nchls.pro/ssl\r\n```\r\n![手机证书](https://ouluqiang.github.io//post-images/1569305456616.jpg)\r\n\r\n勾选Windows代理，打开ssl代理设置\r\n![ssl设置](https://ouluqiang.github.io//post-images/1569305597175.jpg)\r\n\r\n添加主机和端口号， 主机用*，端口号443抓取https，也可以用*\r\n![](https://ouluqiang.github.io//post-images/1569305786428.jpg)\r\n\r\n## Android 7.0抓https失败的解决方案\r\n\r\n新建network_security_config.xml文件\r\n![network_security_config](https://ouluqiang.github.io//post-images/1569302838764.png)\r\n\r\n在network_security_config.xml文件写入以下代码\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<network-security-config>\r\n    <base-config cleartextTrafficPermitted=\"true\">\r\n        <trust-anchors>\r\n            <certificates src=\"system\" overridePins=\"true\" />\r\n            <certificates src=\"user\" overridePins=\"true\" />\r\n        </trust-anchors>\r\n    </base-config>\r\n</network-security-config>\r\n```\r\n\r\n在AndroidManifest.xml添加配置  \r\n\r\n![networkSecurityConfig](https://ouluqiang.github.io//post-images/1569302899586.png)\r\n\r\n\r\n```\r\nandroid:networkSecurityConfig=\"@xml/network_security_config\"\r\n```",
      "data": {
        "title": "charles使用",
        "date": "2019-09-23 18:38:43",
        "tags": [
          "工具",
          "Charles"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "charles基本设置使用\r",
      "fileName": "charles-shi-yong"
    },
    {
      "content": "一些常用正则表达式 \r\n\r\n<!-- more -->\r\n\r\n## 正则判断函数\r\n```\r\nPattern.matches(regex, pass);\r\n```\r\n\r\n## 搜索中文\r\n```\r\n^((?!(\\*|//)).)+[\\u4e00-\\u9fa5]\r\n```\r\n\r\n## 验证密码首位为字母或数字\r\n```\r\n[0-9 a-z A-Z]\\w*\r\n```\r\n\r\n## 验证Email\r\n```\r\n\\w+@\\w+\\.[a-z]+(\\.[a-z]+)?\r\n```\r\n\r\n## 验证身份证号码\r\n```\r\n(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)\r\n```\r\n\r\n## 验证手机号码\r\n```\r\n(\\+\\d+)?1[3456789]\\d{9}$\r\n```\r\n\r\n## 验证固定电话号码\r\n```\r\n(\\+\\d+)?(\\d{3,4}\\-?)?\\d{7,8}$\r\n```\r\n\r\n## 验证整数（正整数和负整数）\r\n```\r\n\\-?[1-9]\\d+\r\n```\r\n\r\n## 验证整数和浮点数（正负整数和正负浮点数）\r\n```\r\n\\-?[1-9]\\d+(\\.\\d+)?\r\n```\r\n\r\n## 验证空白字符\r\n```\r\n\\\\s+\r\n```\r\n\r\n## 验证中文\r\n```\r\n^[\\u4E00-\\u9FA5]+$\r\n```\r\n\r\n## 验证日期（年月日）\r\n```\r\n[1-9]{4}([-./])\\d{1,2}\\1\\d{1,2}\r\n```\r\n\r\n## 验证URL地址\r\n```\r\n(https?://(w{3}\\.)?)?\\w+\\.\\w+(\\.[a-zA-Z]+)*(:\\d{1,5})?(/\\w*)*(\\??(.+=.*)?(&.+=.*)?)?\r\n```\r\n\r\n## 获取网址 URL 的一级域名\r\n```\r\n(?<=http://|\\.)[^.]*?\\.(com|cn|net|org|biz|info|cc|tv)\r\n```\r\n\r\n## 匹配中国邮政编码\r\n```\r\n[1-9]\\d{5}\r\n```\r\n\r\n## 匹配IP地址(简单匹配，格式，如：192.168.1.1，127.0.0.1，没有匹配IP段的大小)\r\n```\r\n[1-9](\\d{1,2})?\\.(0|([1-9](\\d{1,2})?))\\.(0|([1-9](\\d{1,2})?))\\.(0|([1-9](\\d{1,2})?))\r\n```\r\n\r\n",
      "data": {
        "title": "正则表达式",
        "date": "2019-09-23 18:29:08",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "一些常用正则表达式 \r",
      "fileName": "zheng-ze-biao-da-shi"
    },
    {
      "content": "写博客的工具与GitHub的基本配置\n\n<!-- more -->\n\n## 创建github 博客项目\n\n创建一个repo，名称为 yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下：\n\n![创建项目](https://ouluqiang.github.io//post-images/1569307197693.jpg)\n\n\nxxx.github.io  xxx必须是你的用户名，创建项目，我的已经存在了\n\n![](https://ouluqiang.github.io//post-images/1569307241793.jpg)\n\n\n\n\n## [创建一个 Token](https://github.com/settings/tokens/new)\n\n只勾选repo即可，防止token泄漏\n\n![](https://ouluqiang.github.io//post-images/1569307352985.png)\n\n拿到token填写到gridea的基础配置token里\n\n![](https://ouluqiang.github.io//post-images/1569307358531.png)\n\n![](https://ouluqiang.github.io//post-images/1569307416363.png)\n\n检测远程连接成功就可以了，如果确定都填对了，就关闭gridea软件再打开软件检测远程连接\n\n## [创建一个 OAuth](https://github.com/settings/applications/new)\n\n![](https://ouluqiang.github.io//post-images/1569307480431.png)\n\n填写到Gridea的配置评论栏中\n\n![](https://ouluqiang.github.io//post-images/1569307505346.png)\n\n![](https://ouluqiang.github.io//post-images/1569307563455.png)\n\n\n再博客中测试评论，成功即可",
      "data": {
        "title": "Gridea，GitHub配置使用",
        "date": "2019-09-18 18:17:55",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "写博客的工具与GitHub的基本配置",
      "fileName": "grideagithub-pei-zhi-shi-yong"
    },
    {
      "content": "## 连接手机和电脑\n命令行 adb devices 查看连接\n\n![连接](https://ouluqiang.github.io//post-images/1568884026016.png)\n\n   \n## 设置5555端口\n设置wifi调试端口 5555\n```\n    adb tcpip 5555\n```\n\n![端口](https://ouluqiang.github.io//post-images/1568886196625.png)\n\n  \n## 查看手机ip\n```\n    adb shell  ifconfig wlan0\n```\n\n![ip](https://ouluqiang.github.io//post-images/1568886240609.png)\n\n \n手机操作，打开 设置-WLAN-配置 页面，可看到当前 IP\n\n![ip](https://ouluqiang.github.io//post-images/1568886275147.png)\n\n\n## 连接手机 \n```\n    adb connect <手机ip地址>\n```\n\n![连接](https://ouluqiang.github.io//post-images/1568886318164.png)\n\n\n\n## 成功\n连接成功显示\n\n![成功](https://ouluqiang.github.io//post-images/1568886341285.png)\n\n    \n 锤子手机测试失败",
      "data": {
        "title": "adb wifi 调试",
        "date": "2019-09-18 16:48:35",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "adb-wifi-diao-shi"
    },
    {
      "content": "## 新建代码库\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n## 配置\n```\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n## 代码提交\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n## 分支\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n## 标签\n```\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n## 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的代码差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n# 从本地master拉取代码更新当前分支：branch 一般为master\n$ git rebase [branch]\n```\n\n## 远程同步\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n## 撤销\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n## 其他\n```\n# 生成一个可供发布的压缩包\n$ git archive\n```",
      "data": {
        "title": "git命令",
        "date": "2019-09-18 16:28:33",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "git-ming-ling"
    },
    {
      "content": "[简明版教程](http://note.youdao.com/iyoudao/?p=2411)  \n[进阶版教程](http://note.youdao.com/iyoudao/?p=2445)\n## 标题  \n\n**标题，只需要在这段文字前面加上 #，再在 # 后加一个空格  \n增加一个 # ，标题字号相应降低一级**\n![标题](https://ouluqiang.github.io//post-images/1569307892987.png)\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n```\n![标题效果](https://ouluqiang.github.io//post-images/1569307931761.png)\n\n## 列表  \n\n### 无序列表  \n\n**你只需要在文字前面加上 - 就可以了；如果你希望是有序列表，在文字前面加上 1. 2. 3. 即可。**\n![无序列表](https://ouluqiang.github.io//post-images/1569307967486.png)\n\n\n```\n- 列表1\n  - 列表1.1\n  - 列表1.2\n- 列表2\n- 列表3\n```\n\n- 列表1\n  - 列表1.1\n  - 列表1.2\n- 列表2\n- 列表3\n\n\n### 有序列表\n\n![有序列表](https://ouluqiang.github.io//post-images/1569308007512.png)\n\n\n```\n1. 列表1\n    1. 列表1.1\n    2. 列表1.2\n2. 列表2\n3. 列表3\n```\n\n1. 列表1\n    1. 列表1.1\n    2. 列表1.2\n2. 列表2\n3. 列表3\n\n\n\n## 引用\n**如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。  \n在引用文字前加上 > 并与文字保留一个字符的空格**\n\n![引用](https://ouluqiang.github.io//post-images/1569308041174.png)\n\n```\n\t> 记录，成为更好的自己。--有道云笔记 \n```\n\n> 记录，成为更好的自己。--有道云笔记 \n\n\n\n\n## 粗体和斜体\n\n**用两个 * 包含一段文本就是粗体的语法；**    \n**用一个 * 包含一段文本就是斜体的语法。**  \n***注意：字符与文本之间无须空格***\n\n![斜体](https://ouluqiang.github.io//post-images/1569308084185.png)\n\n```\n*这是斜体*\n```\n\n*这是斜体*\n\n![粗体](https://ouluqiang.github.io//post-images/1569308112324.png)\n\n```\n**这是粗体**\n```\n\n**这是粗体**\n\n\n## 链接与图片\n\n**链接：在 Markdown 中，插入链接只需要使用 [显示文本] (链接地址) 即可。**  \n**图片：在 Markdown 中，插入图片只需要使用 ![显示文本] (图片链接地址)即可。**  \n***注：插入图片的语法和链接的语法很像，只是前面多了一个！***  \n\n![链接](https://ouluqiang.github.io//post-images/1569308139421.png)\n\n```\n[链接](https://ouluqiang.github.io)\n```\n\n[链接](https://ouluqiang.github.io)\n\n![图片](https://ouluqiang.github.io//post-images/1569308339148.png)\n\n```\n![图片连接演示](https://ouluqiang.github.io//images/avatar.png?v=1569307577738)\n```\n\n![图片连接演示](https://ouluqiang.github.io//images/avatar.png?v=1569307577738)\n\n\n## 分割线\n\n**只需要另起一行，连续输入三个星号** ***  **即可分割两段文字内容。**\n\n```\n\t第一段\n\t***\n\t第二段\n\n\t第一段\n\t---\n\t第二段\n```\n\n第一段\n***\n第二段\n\n第一段\n---\n第二段\n\n\n\n\n## 代码高亮\n\n![代码高亮](https://ouluqiang.github.io//post-images/1569308458877.png)\n\n![代码高亮代码](https://ouluqiang.github.io//post-images/1569308483292.png)\n\n```\n代码高亮\n```\n\n## 制作待办事项To-do List\n你只需要在待办的事项文本或者清单文本前加上- [ ]、- [x]即可。\n\n**- [] 表示未完成，- [x] 表示已完成。**\n\n***注：键入字符与字符之间都要保留一个字符的空格。***\n\n![已完成](https://ouluqiang.github.io//post-images/1569308519075.png)\n\n```\n- [x] 已完成\n  - [x] 已完成\n  - [x] 已完成  \n```\n\n- [x] 已完成\n  - [x] 已完成\n  - [x] 已完成  \n\n![未完成](https://ouluqiang.github.io//post-images/1569308546303.png)\n\n```\n- [ ] 未完成\n- [ ] 未完成\n```\n\n- [ ] 未完成\n- [ ] 未完成\n\n## 高效绘制 流程图、序列图、甘特图、表格\n### 流程图\n书写graph XX，用以确定将要绘制的流程图及其类型（XX表示流程图类型）。\n流程图分为竖向和横向两大类，竖向包括自上而下和自下而上两种顺序，横向包括从右到左和从左到右两种顺序。  \n其对应语法分别为：graph TB/graph BT/graph RL/graph LR。\n\nTB - top bottom（自上而下）  \nBT - bottom top（自下而上）  \nRL - right left（从右到左）  \nLR - left right（从左到右）  \n\n![流程图](https://ouluqiang.github.io//post-images/1569308580136.png)\n\n![流程图效果](https://ouluqiang.github.io//post-images/1569308601497.png)\n\n\n\n```\ngraph TD\nA[直角四边形]---B{菱形}\nB --> C((圆形))\nC --> D\nC --> E\nC -->|插入文本|F\n```\n\n### 序列图\n\n![序列图](https://ouluqiang.github.io//post-images/1569308625091.png)\n\n![序列图效果](https://ouluqiang.github.io//post-images/1569308658344.png)\n\n\n```\nsequenceDiagram\nloop every day\n    A->>B: How are you?\n\n    B->>A: Great!\nend\n```\n\n### 甘特图\n书写 gantt ，用以确定将要绘制的是甘特图。\ndateFormat YYYY-MM-DD规定了时间轴，title （标题文本）表示甘特图标题。\n需键入section，空一个字符，再输入项目名称的文本（一个section和另一个section之间要空行）。\n\n![甘特图](https://ouluqiang.github.io//post-images/1569308684380.png)\n\n![甘特图效果](https://ouluqiang.github.io//post-images/1569308707886.png)\n\n\n```\ngantt\ndateFormat YYYY-MM-DD\ntitle 产品计划书\nsection 初期阶段\n明确需求: 2018-07-01, 9d\nsection 中期阶段\n跟进开发: 2018-07-11, 9d\nsection 后期阶段\n走查测试: 2018-07-22, 9d\n```\n\n### 表格\n\n![表格](https://ouluqiang.github.io//post-images/1569308736274.png)\n\n\n```\n    header 1    | header 2    | 第三\n    ---         |---          | ---\n    row 1 col 1 | row 1 col 2 | 第三个 \n    row 2 col 1 | row 2 col 2 | 第三个\n```\n\nheader 1    | header 2    | 第三\n---         |---          | ---\nrow 1 col 1 | row 1 col 2 | 第三个 \nrow 2 col 1 | row 2 col 2 | 第三个\n\n\n## 书写数学公式\n\n![公式](https://ouluqiang.github.io//post-images/1569308765985.png)\n\n![公式图](https://ouluqiang.github.io//post-images/1569308783976.png)\n\n```math\nE = mc^2\n```\n\n\n\n",
      "data": {
        "title": "markdown编辑器教程",
        "date": "2019-08-09 17:51:21",
        "tags": [
          "Blog",
          "markdown"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/markdown-bian-ji-qi-jiao-cheng.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "markdown-bian-ji-qi-jiao-cheng"
    },
    {
      "content": "这是关于的页面，可以在这里向世界介绍你！\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": null,
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](http://hvenotes.fehey.com/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **𝖶𝗂𝗇𝖽𝗈𝗐𝗌** 或 **𝖬𝖺𝖼𝖮𝖲** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/hello-gridea.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "name": "Jetpack",
      "slug": "0ERq-Hwpp",
      "used": true
    },
    {
      "name": "Navigation",
      "slug": "TMwFKtlviY",
      "used": true
    },
    {
      "name": "转载",
      "slug": "Bvven-3pQW",
      "used": true
    },
    {
      "name": "kotlin",
      "slug": "oC2Angq_X",
      "used": true
    },
    {
      "index": -1,
      "name": "Android",
      "slug": "uPl9IEkHz",
      "used": true
    },
    {
      "name": "gson",
      "slug": "13AEsKm6N",
      "used": true
    },
    {
      "name": "markdown",
      "slug": "EYP-kC9od",
      "used": true
    },
    {
      "name": "blog",
      "slug": "FO3QcY1pj",
      "used": true
    },
    {
      "name": "Charles",
      "slug": "QXrdbuOAc",
      "used": true
    },
    {
      "name": "工具",
      "slug": "7Y0nywv1q",
      "used": true
    },
    {
      "index": -1,
      "name": "Blog",
      "slug": "wowhDkgzJ",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "ea4LAVIav",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}