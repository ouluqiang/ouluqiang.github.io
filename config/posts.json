{
  "posts": [
    {
      "content": "\r\n-----------------\r\n\r\n以下文章来源于Android波斯湾 ，作者jeanboy\r\n\r\n ![Android波斯湾](http://wx.qlogo.cn/mmhead/Q3auHgzwzM6sNIsuR2eBkbdurCKgNSMxicyZq9XribCL6U3GxQdkBkQA/0) \r\n\r\n**Android波斯湾**\r\n\r\nAndroid | 大前端 技术干货、学习资料、职业发展、行业动态。](#)\r\n\r\n  \r\n\r\n---\r\n\r\n注意文末的准备与建议，大家周一快乐~\r\n\r\n优贝在线\r\n----\r\n\r\n*   Android 项目中 asset 目录和 res 目录有什么区别\r\n    \r\n*   面向对象的特征，并举例说明面向对象的过程\r\n    \r\n*   如何结束一个正在运行的线程\r\n    \r\n*   简述 MVC 和 MVP，并说一下 MVP 的优点\r\n    \r\n*   如何获取某个 View 的大小并动态改变 View 的大小\r\n    \r\n*   join()、wait()、interrupt()\r\n    \r\n*   二维数组旋转\r\n    \r\n*   有一群人A与B有关系，B与C有关系...分成两队，让彼此都有关系\r\n    \r\n\r\n这是一个神奇的公司，只怪自己太菜笔试都没有过，出师不利啊。然而奇怪的是国庆后，该公司的HR找了我不下3次。\r\n\r\n三节课\r\n---\r\n\r\n*   String、StringBuilder、StringBuffer 区别\r\n    \r\n*   ArrayMap、HashMap、SparseArray 原理\r\n    \r\n*   Fragment 添加方式，add、replace、show 区别\r\n    \r\n*   volatile 关键字作用\r\n    \r\n*   Binder 机制\r\n    \r\n*   HTTP 版本之间区别\r\n    \r\n*   invalidate()、requestLayout() 区别\r\n    \r\n*   View 绘制流程\r\n    \r\n*   事件分发机制\r\n    \r\n*   渲染优化\r\n    \r\n*   ArrayList 怎么实现线程安全\r\n    \r\n\r\n必要商城\r\n----\r\n\r\n*   Android 线程间通讯方式有哪些？\r\n    \r\n*   类B继承A，A、B两个类中都有静态变量、成员变量、静态代码块、构造方法执行顺序是什么？\r\n    \r\n*   Java代码执行时内存状况\r\n    \r\n*   Activity生命周期其他函数\r\n    \r\n*   View什么时候绘制完成？\r\n    \r\n*   如何获取一个View的尺寸？\r\n    \r\n\r\n展心展力\r\n----\r\n\r\n*   Handler 机制，一个线程几个 Looper，几个 Handler，Looper 如何确定是哪个 Handler？\r\n    \r\n*   内存溢出、内存泄漏的关系\r\n    \r\n*   volatile、synchronized关键字的区别\r\n    \r\n*   垃圾回收机制，垃圾回收算法优缺点\r\n    \r\n*   Java内存模型的理解\r\n    \r\n*   HashMap实现原理，如何计算key的index，存储方式\r\n    \r\n*   一个无限单向链表如何计算长度，如果有环如何计算长度\r\n    \r\n*   RelativeLayout与LinerLayout的区别\r\n    \r\n*   View绘制原理\r\n    \r\n*   事件分发机制，Activity怎么处理的\r\n    \r\n\r\n团车网\r\n---\r\n\r\n*   自定义 View 流程\r\n    \r\n*   View 绘制原理\r\n    \r\n*   事件分发机制\r\n    \r\n*   AMS、WMS\r\n    \r\n*   Handler 机制\r\n    \r\n*   JMM\r\n    \r\n*   锁机制\r\n    \r\n*   AQS\r\n    \r\n*   内存优化怎么优化\r\n    \r\n*   项目中遇到的最大的问题是什么？怎么解决的\r\n    \r\n*   如果遇到项目进度无法推进，你怎么做的\r\n    \r\n*   你对近五年的规划\r\n    \r\n\r\n某课\r\n--\r\n\r\n*   Handler postDelay() 然后finish当前Activity会怎么样？\r\n    \r\n*   View 绘制流程\r\n    \r\n*   invalidate()、postInvalidate()、requestLayout()\r\n    \r\n*   Tinker 为什么需要重启\r\n    \r\n*   volatile、synchronized\r\n    \r\n*   Java内存模型\r\n    \r\n\r\n这是我迄今体验最差的面试没有之一，面试官特别装逼，一直问我 API 细节，方法里有什么代码（也怪自己太菜，一年多没做 Android了）。最后面试官竟然 JVM 运行时内存区域和 JMM 都分不清，我实在忍不住了反问了一句：公司难道是在招 API 工程师吗？\r\n\r\n诸葛找房\r\n----\r\n\r\n*   事件分发机制\r\n    \r\n*   HTTP 响应吗\r\n    \r\n*   Handler 机制\r\n    \r\n*   手写排序算法\r\n    \r\n*   常用设计模式\r\n    \r\n\r\n异乡好居\r\n----\r\n\r\n*   http https\r\n    \r\n*   js webview交互\r\n    \r\n*   handler为什么不卡死\r\n    \r\n*   App启动流程\r\n    \r\n*   自定义view过程\r\n    \r\n*   动画原理\r\n    \r\n*   事件分发机制\r\n    \r\n*   混淆怎么处理\r\n    \r\n*   设计模式\r\n    \r\n*   对跨平台技术的了解\r\n    \r\n\r\nFineChart\r\n---------\r\n\r\n*   HTTP、HTTPS区别\r\n    \r\n*   HTTP报文\r\n    \r\n*   手写反转链表\r\n    \r\n*   手写单例模式\r\n    \r\n*   volatile关键字原理\r\n    \r\n*   事件分发机制\r\n    \r\n*   App启动流程\r\n    \r\n*   项目天气曲线实现原理\r\n    \r\n*   第三方开源库实现原理\r\n    \r\n*   线程池原理\r\n    \r\n*   wait()、sleep()区别\r\n    \r\n*   项目中最大的困难是什么？怎么解决的？\r\n    \r\n*   常用集合类实现原理\r\n    \r\n*   ConcurrentHashMap原理\r\n    \r\n\r\n阿里体育\r\n----\r\n\r\n### 电面\r\n\r\n*   List、Map、Set 哪个能存null，哪个能重复？\r\n    \r\n*   补间动画与属性动画的区别\r\n    \r\n*   Handler 机制\r\n    \r\n\r\n### 一面\r\n\r\n*   怎么实现View悬停？\r\n    \r\n*   TCP怎么做长连接？\r\n    \r\n*   网络优化\r\n    \r\n*   热修复原理\r\n    \r\n*   Instant Run原理\r\n    \r\n*   视频做过吗？\r\n    \r\n*   相机做过吗？\r\n    \r\n*   LinkedHashMap、HashMap实现原理，区别是什么？\r\n    \r\n\r\n### 二面\r\n\r\n*   Android与iOS相比有什么差别\r\n    \r\n*   Android与iOS系统内存管理机制了解吗？\r\n    \r\n*   常见算法了解哪些，时间复杂度是什么？\r\n    \r\n*   项目中遇到的困难是什么？怎么解决的？\r\n    \r\n*   你最大的优势是什么？\r\n    \r\n*   对于其他同事，为什么你觉得你这个优势最突出？\r\n    \r\n\r\n不得不承认阿里实力还是很强的，也可能我投的岗位期望 P7 以上水平的缘故，被虐的很惨。突然感觉这几年都荒废了，选择大于努力，一定要选择好的方向，比如我选择小程序就是一个错误。\r\n\r\n多点科技\r\n----\r\n\r\n### 一面\r\n\r\n*   HashMap、ArrayMap\r\n    \r\n*   Handler、IdleHandler、postDelay\r\n    \r\n*   View 绘制原理\r\n    \r\n*   事件分发机制\r\n    \r\n*   如果子View已经处理了事件，父View怎么拦截子View事件\r\n    \r\n*   Binder机制\r\n    \r\n*   线程池原理\r\n    \r\n*   垃圾回收机制\r\n    \r\n*   类加载机制\r\n    \r\n\r\n### 二面\r\n\r\n*   OkHttp、Retrofit、Glide、ButterKnife、EventBus、RxJava\r\n    \r\n*   Jetpack、LiveData、ViewModel\r\n    \r\n*   ArrayList、LinkedList\r\n    \r\n*   Material Design\r\n    \r\n*   Java并发编程（JMM）\r\n    \r\n*   MVP、MVVM区别\r\n    \r\n\r\n### HR面\r\n\r\n*   期望什么样的领导？\r\n    \r\n*   期望加入什么样的公司？\r\n    \r\n*   拿到几个Offer了？\r\n    \r\n*   期望薪资？\r\n    \r\n\r\n### 董事之一\r\n\r\n*   介绍了下公司的发展前景，公司的优势\r\n    \r\n*   对未来工作的期望？\r\n    \r\n*   聊了将近一个小时...\r\n    \r\n\r\n美餐网\r\n---\r\n\r\n*   怎么判断二叉搜索树是否合法，白板手写出解法\r\n    \r\n*   给出一个业务场景怎么处理\r\n    \r\n\r\n你没有看错，就只有两道面试题，白板手写代码，这是我遇到的最奇葩的公司了，最后还说我代码写的不讲究（这 tm 是面试吧，我已经说了由于篇幅有限，一些细节就忽略了），太浪费时间了。\r\n\r\n360\r\n---\r\n\r\n### 一面\r\n\r\n*   线程状态转换图\r\n    \r\n*   Activity生命周期，一个Activity启动另外一个Activity生命周期函数调用\r\n    \r\n*   Activity启动模式，onNewIntent() 调用时机\r\n    \r\n*   动画有哪些，实现原理\r\n    \r\n*   setContentView()后面的流程\r\n    \r\n*   Handler机制，Looper与ANR\r\n    \r\n*   过度重绘、UI卡顿\r\n    \r\n*   WindowManager.addView()，View.getParent()是谁？\r\n    \r\n*   JMM理解\r\n    \r\n*   Lock机制\r\n    \r\n\r\n### 二面\r\n\r\n*   内存泄露、内存溢出\r\n    \r\n*   类加载机制、双亲委派模型\r\n    \r\n*   CAS\r\n    \r\n*   有多个线程1、2、3、4，1、2、3 并行完后与 4 串行，至少 3 种方式实现\r\n    \r\n*   网络参考模型\r\n    \r\n*   HTTP、HTTPS传输过程\r\n    \r\n*   TCP三次握手、四次挥手\r\n    \r\n*   用过哪些设计模式\r\n    \r\n*   根据简历多渠道包怎么构建的\r\n    \r\n*   反射原理\r\n    \r\n\r\n### 三面\r\n\r\n*   一般都是根据简历问\r\n    \r\n*   对大前端技术的了解\r\n    \r\n*   类加载机制\r\n    \r\n*   对JDK各版本差异的了解\r\n    \r\n*   Android系统启动流程\r\n    \r\n*   AMS、WMS\r\n    \r\n*   对Framework层源码的了解，为什么这么设计，优缺点\r\n    \r\n\r\n关于准备\r\n----\r\n\r\n每个人应聘的职位级别不一样，需要准备的范围也有所不同。我应聘的是高级职位，主要准备了以下几点：\r\n\r\n**Java 基础**\r\n\r\n一般都会问 Java 虚拟机相关知识：类加载机制、双亲委派模型、垃圾回收机制、运行时内存区域、注解、泛型、反射等等。强烈建议精读一下《深入理解 Java 虚拟机》这本书。\r\n\r\nJava 并发编程也是高级必问知识：Thread生命周期、JMM、volatile、synchronizied、final、JUC、Lock、线程池等等。推荐看一下《Java 并发编程的艺术》。\r\n\r\n**Android 基础**\r\n\r\n这部分内容比较多，还是需要平时多积累，养成看源码的习惯。\r\n\r\n现在一般都不仅仅问原理是什么了，比如 View 绘制原理会问 requestLayout() 和 invalidate() 什么区别？什么情况下 requestLayout() 会执行 onDraw() 方法？\r\n\r\nHandler 机制大家都会说，网上找找都能找到，现在会问一个线程几个 Looper，几个 Handler？Looper 中的死循环为什么不会卡死主线程？IdleHandler 的原理？发送延时消息怎么处理的？\r\n\r\n如果你能从 Handler 答出 epoll 机制，接下来会问 epoll 机制的原理，有没有看过源码？\r\n\r\n高级岗位 Framework 层原理肯定逃不过的，系统启动流程、Binder、AMS、WMS 都是最基础的，最好有一个自己深入研究的方向，比如 SurfaceFlinger。\r\n\r\n进阶一定要看刚哥的《Android 开发艺术探索》必备，Framework 部分《Android 内核剖析》、《Android 源码情景解析》、《深入理解 Android》系列等都是很不错的书籍。\r\n\r\n另外强烈推荐张绍文的《Android开发高手课》。\r\n\r\n**网络基础**\r\n\r\n面试中一般会问 HTTP 的三次握手、四次挥手过程，以及为什么？HTTPS 的通讯过程？等等。\r\n\r\n网络是个大方向，对于 Android 工程师来说，常见的概念必须要了解的，当然深入研究一下也是很不错的加分项。就像直播，网络优化等方面都离不开网络知识。\r\n\r\n推荐看一下《图解 HTTP》、《图解 TCP/IP》，向深入研究可以看《TCP/IP 详解》、《UNIX 网络编程》。\r\n\r\n**数据结构与算法**\r\n\r\n数据结构计算机专业的一般都是必修课，网上资料很多这里就不推荐了。\r\n\r\n面试中数据结构一般会问 Java 集合类：ArrayList、HashMap、ConcurrentHashMap 等等，常见的高频算法题一定要准备下。\r\n\r\n算法可以看看《算法》、《算法导论》、覃超的《算法面试通关 40 讲》、刷下 LeetCode。\r\n\r\n**设计模式与架构**\r\n\r\n设计模式一般会问你在项目中常用的设计模式有那些？等你说完之后会问你怎么用的，什么场景用的？它的优缺点是什么？遵循了什么原则？违背了什么原则？...\r\n\r\n架构 MVC、MVP、MVVM 烂大街的问题，一般会问它们的优缺点各是什么？\r\n\r\n总结\r\n--\r\n\r\n虽然后面还有好几家面试，也有像豹厂这样的很不错的公司。但不得不承认一天面两家，一周面 10 家实在太累了。\r\n\r\n在收到大数字公司的 Offer 后就没有再面了，加上 HR 将近五轮的面试聊得过程都很愉快，大数字公司也是我比较理想的公司。\r\n\r\n虽然在之前也收到了几家很不错 Offer，相比之下还是大数字公司比较适合我，接下里的几年也需要好好沉淀一下技术了。\r\n\r\n经过这一次的被动面试经历，我个人感受有以下几点：\r\n\r\n**一定不要裸辞**\r\n\r\n如果是裸辞找工作，HR 一般都会问什么时候离职的。如果手里没有 Offer，就很被动了，很有可能被压薪资。主动权一定要掌握在自己手中。\r\n\r\n**选择大于努力**\r\n\r\n即使很努力如果方向错了就是浪费时间，就像我选择了小程序就是个错误（大前端坑太多，入坑需谨慎）。我的建议是多深入研究一些以不变应万变的技能。\r\n\r\n**学历与履历**\r\n\r\n虽然说能力很重要，但学历是敲门砖（HR 就看这个）。如果连面试机会都没有，还怎么谈然后？如果学历不突出有很好的大厂履历也很不错，貌似是个蛋生鸡，鸡生蛋的问题。\r\n\r\n**充分准备**\r\n\r\n一些基础知识和理论肯定是要背的，要理解的背，用自己的语言总结一下背下来。\r\n\r\n虽然 Android 没有前几年火热了，已经过去了会四大组件就能找到高薪职位的时代了。这只能说明 Android 中级以下的岗位饱和了，现在高级工程师还是比较缺少的，我能明显感觉到国庆后多了很多高级职位，所以努力让自己成为高级工程师才是最重要的。\r\n\r\n好了，希望对大家有所帮助。\r\n\r\n  \r\n\r\n  \r\n",
      "data": {
        "title": "[转载] 被辞退后，一周面试了 10 家公司",
        "date": "2019-11-18 09:49:56",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "bei-ci-tui-hou-yi-zhou-mian-shi-liao-10-jia-gong-si-zhuan-zai"
    },
    {
      "content": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/94003014](https://blog.csdn.net/lyhhj/article/details/94003014)\r\n\r\n<!-- more -->\r\n\r\n> 上篇文章我们简单的介绍了**Navigation组件**的使用，以及深入分析了源码中的具体实现，基本原理我们已经很清晰了。本篇文章主要介绍下我在项目中遇到的问题，以及目前关于**Navigation**实现的一些探讨。还没有看过上篇文章的可以查看一下：\r\n\r\n[1\\. Jetpack源码解析—看完你就知道Navigation是什么了？](https://blog.csdn.net/lyhhj/article/details/93757755)\r\n\r\n1\\. 背景\r\n======\r\n\r\n先来看一下`Navigation`组件在官方文档上的介绍：\r\n\r\n> 今天，我们宣布推出Navigation组件，作为构建您的应用内界面的框架，重点是让单 Activity 应用成为首选架构。利用Navigation组件对 Fragment 的原生支持，您可以获得架构组件的所有好处（例如生命周期和 ViewModel），同时让此组件为您处理 FragmentTransaction 的复杂性。此外，Navigation组件还可以让您声明我们为您处理的转场。它可以自动构建正确的“向上”和“返回”行为，包含对深层链接的完整支持，并提供了帮助程序，用于将导航关联到合适的 UI 小部件，例如抽屉式导航栏和底部导航。\r\n\r\n确实经过源码分析我们就可以发现，`Navigation`组件封装了`Menu`菜单栏、`Fragment`的切换、`NavigationView`、`Drawerlayout`等一系列涉及到的组件，为了更方便的让我们使用单Activity多Fragment的架构。\r\n\r\n但是我在使用的时候发现，当一个`Fragment`中的布局稍微复杂一些，切换`Fragment`的时候会顿卡，而且如果再配合`DrawrLayout`使用的话，还会闪一下屏，效果体验不是很好，本着这个问题，我又再次对`Navigation`组件进行了分析。\r\n\r\n2.Fragment切换\r\n============\r\n\r\n通过现象分析，发现当切换`NavigationView`中的menu菜单来切换`Fragment`时，`DrawerLayout`抽屉关闭有一个短暂的动画(具体的这里就不分析了,感兴趣的可以自行查看，但是这不是根本原因)，同时`Fragment`切换，发生顿卡和闪屏的现象。所以…还是看源码吧：\r\n\r\n2.1 NavController\r\n-----------------\r\n\r\n    private void navigate(@NonNull NavDestination node, @Nullable Bundle args,\r\n                @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {\r\n            boolean popped = false;\r\n            ....\r\n            Navigator<NavDestination> navigator = mNavigatorProvider.getNavigator(\r\n                    node.getNavigatorName());\r\n            Bundle finalArgs = node.addInDefaultArgs(args);\r\n            NavDestination newDest = navigator.navigate(node, finalArgs,\r\n                    navOptions, navigatorExtras);\r\n           ....\r\n        }\r\n    \r\n    \r\n\r\n2.2 FragmentNavigator\r\n---------------------\r\n\r\n    public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,\r\n                @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {\r\n            ...\r\n            //根据classname反射获取Fragmnent\r\n            final Fragment frag = instantiateFragment(mContext, mFragmentManager,\r\n                    className, args);\r\n            frag.setArguments(args);\r\n            //获取Fragment事务\r\n            final FragmentTransaction ft = mFragmentManager.beginTransaction();\r\n            //切换动画设置\r\n            int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1;\r\n            int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1;\r\n            int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1;\r\n            int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1;\r\n            if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) {\r\n                enterAnim = enterAnim != -1 ? enterAnim : 0;\r\n                exitAnim = exitAnim != -1 ? exitAnim : 0;\r\n                popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0;\r\n                popExitAnim = popExitAnim != -1 ? popExitAnim : 0;\r\n                ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim);\r\n            }\r\n            //切换Fragment\r\n            ft.replace(mContainerId, frag);\r\n            ft.setPrimaryNavigationFragment(frag);\r\n            ......\r\n            \r\n            ft.addToBackStack(generateBackStackName(mBackStack.size(), destId));\r\n            ........\r\n        }\r\n    \r\n\r\n看到这里就很清楚了吧，`Fragment`的切换是通过`replace`方式来切换的，并且加入回退栈，也就是说每次切换`Fragment`,都会销毁视图和重新创建视图。至于为什么用这种方式我是真的想不到，也没搞清楚初衷是什么？按照我们目前的开发来说，`Fragment`的切换通常都会使用`hide()`、`show()`，而`replcae()`的方式很少用，替换会把容器中的所有内容全都替换掉，有一些app会使用这样的做法，保持只有一个fragment在显示，减少了界面的层级关系。\r\n\r\n> 不仅仅是这样，上篇文章有小伙伴问切换了`Fragment`之后，点击返回按钮，发现之前的`Fragment`重走了`onCreateView`流程，这就意味着之前的状态没了。对于这个问题其实根据上面的分析，也能大概想到是因为什么，但是返回按钮的操作我之前还真没有看过源码，所以这次顺便了解一下：\r\n\r\n3\\. 返回都做了什么\r\n===========\r\n\r\n3.1 onBackPressed\r\n-----------------\r\n\r\n我们同样从首页的`onBackPressed`入手：\r\n\r\n    override fun onBackPressed() {\r\n            if (drawerLayout.isDrawerOpen(GravityCompat.START)) {\r\n                drawerLayout.closeDrawer(GravityCompat.START)\r\n            } else {\r\n                super.onBackPressed()\r\n            }\r\n        }\r\n    \r\n\r\n    public void onBackPressed() {\r\n            mOnBackPressedDispatcher.onBackPressed();\r\n        }\r\n    \r\n\r\n最终调用了`mOnBackPressedDispatcher`的`onBackPressed()`方法。我们查看这个类，通过**Debug**调试，我们跟到了`FragmentManagerImpl`类：\r\n\r\n    private final OnBackPressedCallback mOnBackPressedCallback =\r\n                new OnBackPressedCallback(false) {\r\n            @Override\r\n            public void handleOnBackPressed() {\r\n                FragmentManagerImpl.this.handleOnBackPressed();\r\n            }\r\n        };\r\n    \r\n\r\n发现点击返回按钮之后就走到这个，执行`handleOnBackPressed()`方法。\r\n\r\n3.2 FragmentManagerImpl\r\n-----------------------\r\n\r\n继续跟踪源码，中间的一些过程我这里就忽略掉了，大部分都是一些`popBackStack`的操作，这里我们直接跟踪到关键点：\r\n\r\n    //在BackStackRecords中进行入栈出栈操作。\r\n    private static void executeOps(ArrayList<BackStackRecord> records,\r\n                                       ArrayList<Boolean> isRecordPop, int startIndex, int endIndex) {\r\n            for (int i = startIndex; i < endIndex; i++) {\r\n                final BackStackRecord record = records.get(i);\r\n                final boolean isPop = isRecordPop.get(i);\r\n                if (isPop) {\r\n                    record.bumpBackStackNesting(-1);\r\n                    // Only execute the add operations at the end of\r\n                    // all transactions.\r\n                    boolean moveToState = i == (endIndex - 1);\r\n                    record.executePopOps(moveToState);\r\n                } else {\r\n                    record.bumpBackStackNesting(1);\r\n                    record.executeOps();\r\n                }\r\n            }\r\n        }\r\n    \r\n\r\n我们可以看到通过遍历栈数组，对`record`做`executePopOps()`操作，通过cmd来让`FragmentManager`做相关操作。\r\n\r\n    void executePopOps(boolean moveToState) {\r\n            for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) {\r\n                final Op op = mOps.get(opNum);\r\n                Fragment f = op.mFragment;\r\n                if (f != null) {\r\n                    f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition),\r\n                            mTransitionStyle);\r\n                }\r\n                switch (op.mCmd) {\r\n                    case OP_ADD:\r\n                        f.setNextAnim(op.mPopExitAnim);\r\n                        mManager.removeFragment(f);\r\n                        break;\r\n                    case OP_REMOVE:\r\n                        f.setNextAnim(op.mPopEnterAnim);\r\n                        mManager.addFragment(f, false);\r\n                        break;\r\n                    case OP_HIDE:\r\n                        f.setNextAnim(op.mPopEnterAnim);\r\n                        mManager.showFragment(f);\r\n                        break;\r\n                    case OP_SHOW:\r\n                        f.setNextAnim(op.mPopExitAnim);\r\n                        mManager.hideFragment(f);\r\n                        break;\r\n                    case OP_DETACH:\r\n                        f.setNextAnim(op.mPopEnterAnim);\r\n                        mManager.attachFragment(f);\r\n                        break;\r\n                    case OP_ATTACH:\r\n                        f.setNextAnim(op.mPopExitAnim);\r\n                        mManager.detachFragment(f);\r\n                        break;\r\n                    case OP_SET_PRIMARY_NAV:\r\n                        mManager.setPrimaryNavigationFragment(null);\r\n                        break;\r\n                    case OP_UNSET_PRIMARY_NAV:\r\n                        mManager.setPrimaryNavigationFragment(f);\r\n                        break;\r\n                    case OP_SET_MAX_LIFECYCLE:\r\n                        mManager.setMaxLifecycle(f, op.mOldMaxState);\r\n                        break;\r\n                    default:\r\n                        throw new IllegalArgumentException(\"Unknown cmd: \" + op.mCmd);\r\n                }\r\n                if (!mReorderingAllowed && op.mCmd != OP_REMOVE && f != null) {\r\n                    mManager.moveFragmentToExpectedState(f);\r\n                }\r\n            }\r\n            if (!mReorderingAllowed && moveToState) {\r\n                mManager.moveToState(mManager.mCurState, true);\r\n            }\r\n        }\r\n    \r\n\r\n同时重新设置`PrimaryNavigationFragment`，add我们的首页`Fragment`，最后执行`moveToState`方法：\r\n\r\n    public void addFragment(Fragment fragment, boolean moveToStateNow) {\r\n            if (DEBUG) Log.v(TAG, \"add: \" + fragment);\r\n            makeActive(fragment);\r\n            if (!fragment.mDetached) {\r\n                if (mAdded.contains(fragment)) {\r\n                    throw new IllegalStateException(\"Fragment already added: \" + fragment);\r\n                }\r\n                synchronized (mAdded) {\r\n                    mAdded.add(fragment);\r\n                }\r\n                fragment.mAdded = true;\r\n                fragment.mRemoving = false;\r\n                if (fragment.mView == null) {\r\n                    fragment.mHiddenChanged = false;\r\n                }\r\n                if (isMenuAvailable(fragment)) {\r\n                    mNeedMenuInvalidate = true;\r\n                }\r\n                if (moveToStateNow) {\r\n                    moveToState(fragment);\r\n                }\r\n            }\r\n        }\r\n    \r\n\r\n当我们继续跟踪的时候就会发现，在`moveToState`方法中，`Fragment`的state是`Fragment.CREATED`，并且会执行`performCreateView()`中的`onCreateView()`方法：\r\n\r\n        f.mContainer = container;\r\n        f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);\r\n    \r\n\r\n    void performCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\r\n                @Nullable Bundle savedInstanceState) {\r\n            mChildFragmentManager.noteStateNotSaved();\r\n            mPerformedCreateView = true;\r\n            mViewLifecycleOwner = new FragmentViewLifecycleOwner();\r\n            mView = onCreateView(inflater, container, savedInstanceState);\r\n            ....\r\n        }\r\n    \r\n\r\n到这里就基本结束了，我只分析了一个大概，可以了解到点击返回按钮，同样也会重新创建视图，也就是`onCreateView`会重新走一遍。\r\n\r\n4\\. 总结\r\n======\r\n\r\n对于`Navigation`组件的这种切换方式，我也很无奈，而且也并没有暴露出来API供我们使用其他切换方式，我也询问了很多大佬，他们也不是很清楚，也有的发现这也是`Navigation`的一个很大的诟病。那么有没有解决办法呢？很遗憾我目前还没有想到比较好的办法。\r\n\r\n> 基于`Navigation`用来承载`Fragment`的容器是`NavHostFragment`，所以我们并不能使用`ViewPager+Fragment`的通过`setUserVisibleHint`实现懒加载的方式；同样我们也没办法使用`onHiddenChanged`的方式来实现复杂逻辑的加载；但是你可以在进入`Fragment`的时候先显示一个Loading框，加载完数据之后再渲染布局，这样的话可以减少一些尴尬。\r\n\r\n4.1 建议\r\n------\r\n\r\n这里我的建议是：如果你的每个`Fragment`真的每次都需要重新绘制的话，你可以考虑使用`Navigation`组件来实现，毕竟通过`Navgation`组件真的很方便帮助我们切换导航，而且虽然布局会重新绘制，但是Google的官方Demo–[SunFlower](https://github.com/googlesamples/android-sunflower)还是使用了这种方式，所以这里面我觉得：官方推荐我们使用Jetpack组件中的**ViewModel**、**LiveData**…等，可以发现**SunFlower**demo中，即便是切换Fragmengt也不会有很明显的卡顿现象，因为每个Fragment即便重新绘制，但是View所对应的**ViewModel**还在，数据并不需要重新加载或者请求，当然这仅仅是我自己的看法啊.\r\n\r\n但是如果你没有这种场景的话，建议还是用普通的方式我们自己来控制切换吧，这样无论是基于`Drawerlayout`还是`BottomNaivgationView`的话，我们可以自己实现切换。这块我也不是很确定哈，也希望听取大家的意见和建议。\r\n\r\n> 我还发现一个问题，就是Play商店，现在就是这样的情况，抽屉栏中的`Item`每个基本都是重新绘制，而且第一个`Item`**我的应用和游戏**切换的时候就会有很明显的卡顿和闪屏，猜测Google play 商店具体是不是使用的`Navigation`组件不敢确定，但是它很大几率是通过`replace`方式来做的切换。感兴趣的话可以看一下，我这贴一个GIF图，不一定能看清楚，不过确实是这个效果。\r\n\r\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS82LzI2LzE2YjkzMTIzMjZlYzRmZDY)\r\n\r\n最后，如果有不对的地方或者更好的解决办法，可以一起讨论一下哈！",
      "data": {
        "title": "[转载] 2. Jetpack源码解析---Navigation为什么切换Fragment会重绘？",
        "date": "2019-10-15 17:12:29",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/94003014](https://blog.csdn.net/lyhhj/article/details/94003014)\r",
      "fileName": "zhuan-zai-2-jetpack-yuan-ma-jie-xi-navigation-wei-shi-me-qie-huan-fragment-hui-chong-hui"
    },
    {
      "content": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/91440191](https://blog.csdn.net/lyhhj/article/details/91440191)\r\n\r\n<!-- more -->\r\n\r\n1\\. 背景\r\n======\r\n\r\n> 上一篇我门对Jetpack组件中的`Navigation`做了介绍，并且对其做了源码分析，相信看过之后已经对此有了一定的了解，本篇文章我们会对`Lifecycles`进行使用及源码的介绍，还没看上篇的可以看一下：\r\n\r\n**系列文章**：\r\n\r\n[1\\. Jetpack源码解析—看完你就知道Navigation是什么了？](https://blog.csdn.net/lyhhj/article/details/93757755)\r\n\r\n[2\\. Jetpack源码解析—Navigation为什么切换Fragment会重绘？](https://blog.csdn.net/lyhhj/article/details/94003014)\r\n\r\n2\\. 基础\r\n======\r\n\r\n  \r\n\r\n2.1 简介\r\n------\r\n\r\n`Lifecycles`是一个持有组件生命周期状态（如Activity、Fragment）信息的类，并允许其他对象观察此状态。可以帮助我们方便的管理`Activity`和`Fragment`的生命周期。\r\n\r\n`Lifecycle组件`中通过两个枚举类来跟踪其关联组件的生命周期：  \r\n  \r\n![](https://img-blog.csdn.net/20180610101922250?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXh3bGw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70#align=left&display=inline&height=381&originHeight=381&originWidth=700&status=done&width=700)\r\n\r\n  \r\n\r\n2.2 基本使用\r\n--------\r\n\r\n> 在我们的日常开发中，经常需要我们在Activity或者Fragment的生命周期方法中手动去管理一下资源的释放等行为。举个简单的例子，当我们做自定义相机扫描的时候，camera相关的资源就需要我们手动的去释放及开启预览；或者我们在使用MVP模式去开发的时候，P的创建和销毁也需要我们在生命周期方法中去操作。\r\n\r\n通过`Lifecycles组件`我们可以这样使用：  \r\n  \r\n我们可以定义一个Observer实现`LifecycleObserver`，并且在`Activity`或者`Fragment`中进行观察：\r\n\r\n    /**\r\n     * created by ${Hankkin}\r\n     * on 2019-06-10\r\n     */\r\n    \r\n    class MyObserver : LifecycleObserver {\r\n    \r\n        @OnLifecycleEvent(Lifecycle.Event.ON_START)\r\n        fun onStart() {\r\n            Log.e(javaClass.name, \"-------onStart\")\r\n        }\r\n    \r\n        @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)\r\n        fun onCreate() {\r\n            Log.e(javaClass.name, \"-------onCreate\")\r\n        }\r\n    \r\n        @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\r\n        fun onResume() {\r\n            Log.e(javaClass.name, \"-------onResume\")\r\n        }\r\n    \r\n        @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\r\n        fun onPause() {\r\n            Log.e(javaClass.name, \"-------onPause\")\r\n        }\r\n    \r\n    \r\n        @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\r\n        fun onStop() {\r\n            Log.e(javaClass.name, \"-------onStop\")\r\n        }\r\n    \r\n    \r\n        @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)\r\n        fun onDestroy() {\r\n            Log.e(javaClass.name, \"-------onDestroy\")\r\n        }\r\n    \r\n    }\r\n    \r\n\r\n下面是Activity：\r\n\r\n    class MainActivity : AppCompatActivity() {\r\n        \r\n        override fun onCreate(savedInstanceState: Bundle?) {\r\n            super.onCreate(savedInstanceState)\r\n            setContentView(R.layout.activity_main)\r\n    \r\n    \r\n            lifecycle.addObserver(MyObserver())\r\n            Log.e(javaClass.name, \"-------onCreate\")\r\n    \r\n        }\r\n    \r\n        override fun onStart() {\r\n            super.onStart()\r\n            Log.e(javaClass.name, \"-------onStart\")\r\n        }\r\n    \r\n        override fun onResume() {\r\n            super.onResume()\r\n            Log.e(javaClass.name, \"-------onResume\")\r\n        }\r\n    \r\n        override fun onPause() {\r\n            super.onPause()\r\n            Log.e(javaClass.name, \"-------onPause\")\r\n        }\r\n    \r\n        override fun onStop() {\r\n            super.onStop()\r\n            Log.e(javaClass.name, \"-------onStop\")\r\n        }\r\n    \r\n        override fun onDestroy() {\r\n            super.onDestroy()\r\n            Log.e(javaClass.name, \"-------onDestroy\")\r\n        }\r\n    }\r\n    \r\n\r\n启动Activity，我们可以看到控制台中的打印日志：\r\n\r\n    MainActivity: -------onCreate\r\n    MyObserver: -------onCreate\r\n    MainActivity: -------onStart\r\n    MyObserver: -------onStart\r\n    MainActivity: -------onResume\r\n    MyObserver: -------onResume\r\n    ......\r\n    \r\n\r\n通过控制台打印我们可以看到我们的观察者Activity和被观察者的日志均被打印了。具体是怎么实现的呢？\r\n\r\n  \r\n\r\n3\\. 源码分析\r\n========\r\n\r\n通过代码我们大概能看出来`Lifecycles`组件是通过观察者模式来实现的，接下来我们具体分析实现原理，我们发现在`Activity`和`Fragment`中可以直接通过`getLifecycle()`方法获取到`Lifecycle`，那么我们就从这里入手:\r\n\r\n  \r\n\r\n3.1 getLifecycle()\r\n------------------\r\n\r\n我们点击进去发现**ComponentActivity**中实现了`LifecycleOwner`接口，`LifecycleOwner`接口中则声明了`getLifecycle()`方法，而**ComponentActivity**中直接返回了**mLifecycleRegistry**：\r\n\r\n    public class ComponentActivity extends androidx.core.app.ComponentActivity implements\r\n            LifecycleOwner,\r\n            ViewModelStoreOwner,\r\n            SavedStateRegistryOwner,\r\n            OnBackPressedDispatcherOwner {\r\n    \r\n        private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\r\n        ......\r\n        @NonNull\r\n        @Override\r\n        public Lifecycle getLifecycle() {\r\n            return mLifecycleRegistry;\r\n        }\r\n    \r\n\r\n`LifecycleRegistry`是个什么东西呢？原来它继承了**Lifecycle**\r\n\r\n    public class LifecycleRegistry extends Lifecycle\r\n    \r\n\r\n  \r\n\r\n3.2 Lifecycle和LifecycleRegistry\r\n-------------------------------\r\n\r\n我们看一下Lifecycle类：\r\n\r\n    public abstract class Lifecycle {\r\n    \r\n            //注册LifecycleObserver （比如Presenter）\r\n            public abstract void addObserver(@NonNull LifecycleObserver observer);\r\n            //移除LifecycleObserver \r\n            public abstract void removeObserver(@NonNull LifecycleObserver observer);\r\n            //获取当前状态\r\n            public abstract State getCurrentState();\r\n    \r\n            public enum Event {\r\n                ON_CREATE,\r\n                ON_START,\r\n                ON_RESUME,\r\n                ON_PAUSE,\r\n                ON_STOP,\r\n                ON_DESTROY,\r\n                ON_ANY\r\n            }\r\n            \r\n           public enum State {\r\n                DESTROYED,\r\n                INITIALIZED,\r\n                CREATED,\r\n                STARTED,\r\n                RESUMED;\r\n    \r\n                public boolean isAtLeast(@NonNull State state) {\r\n                    return compareTo(state) >= 0;\r\n                }\r\n           }\r\n    }\r\n    \r\n\r\n**Lifecycle**中就是声明了一些抽象方法和两个状态的枚举类，具体的实现看**LifecycleRegistry**：\r\n\r\n    public class LifecycleRegistry extends Lifecycle {\r\n    \r\n    // LifecycleObserver Map，每一个Observer都有一个State\r\n        private FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap = new FastSafeIterableMap<>();\r\n        // 当前的状态\r\n        private State mState;\r\n        // 生命周期拥有者，ComponentActivity继承了LifecycleOwner\r\n        private final WeakReference<LifecycleOwner> mLifecycleOwner;\r\n    \r\n        //修改State值\r\n        private void moveToState(State next) {\r\n            if (mState == next) {\r\n                return;\r\n            }\r\n            mState = next;\r\n            if (mHandlingEvent || mAddingObserverCounter != 0) {\r\n                mNewEventOccurred = true;\r\n                // we will figure out what to do on upper level.\r\n                return;\r\n            }\r\n            mHandlingEvent = true;\r\n            sync();\r\n            mHandlingEvent = false;\r\n        }\r\n    \r\n        /**\r\n        * 添加LifecycleObserver观察者，并将之前的状态分发给这个Observer,例如我们在onResume之后注册这个Observer，\r\n        * 该Observer依然能收到ON_CREATE事件\r\n        */\r\n        @Override\r\n        public void addObserver(@NonNull LifecycleObserver observer) {\r\n            State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\r\n            //新建带有状态的观察者\r\n            ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\r\n            ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\r\n            ......\r\n            // 例如：Observer初始状态是INITIALIZED，当前状态是RESUMED，需要将INITIALIZED到RESUMED之间的\r\n            // 所有事件分发给Observer\r\n            while ((statefulObserver.mState.compareTo(targetState) < 0\r\n                    && mObserverMap.contains(observer))) {\r\n                pushParentState(statefulObserver.mState);\r\n                statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\r\n                popParentState();\r\n                targetState = calculateTargetState(observer);\r\n            }\r\n            ......\r\n    }\r\n    \r\n    /**\r\n         * 同步Observer状态，并分发事件\r\n         */\r\n        private void sync() {\r\n            LifecycleOwner lfecycleOwner = mLifecycleOwner.get();\r\n            if (lifecycleOwner == null) {\r\n                Log.w(LOG_TAG, \"LifecycleOwner is garbage collected, you shouldn't try dispatch \"\r\n                        + \"new events from it.\");\r\n                return;\r\n            }\r\n            while (!isSynced()) {\r\n                mNewEventOccurred = false;\r\n                // State中，状态值是从DESTROYED-INITIALIZED-CREATED-STARTED-RESUMED增大\r\n                // 如果当前状态值 < Observer状态值，需要通知Observer减小状态值，直到等于当前状态值\r\n                if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {\r\n                    backwardPass(lifecycleOwner);\r\n                }\r\n                Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();\r\n                // 如果当前状态值 > Observer状态值，需要通知Observer增大状态值，直到等于当前状态值\r\n                if (!mNewEventOccurred && newest != null\r\n                        && mState.compareTo(newest.getValue().mState) > 0) {\r\n                    forwardPass(lifecycleOwner);\r\n                }\r\n            }\r\n            mNewEventOccurred = false;\r\n        }\r\n    \r\n        /**\r\n         * 向前传递事件，对应图中的INITIALIZED -> RESUMED\r\n         * 增加Observer的状态值，直到状态值等于当前状态值\r\n         */\r\n        private void forwardPass(LifecycleOwner lifecycleOwner) {\r\n            Iterator<Entry<LifecycleObserver, ObserverWithState>> ascendingIterator =\r\n                    mObserverMap.iteratorWithAdditions();\r\n            while (ascendingIterator.hasNext() && !mNewEventOccurred) {\r\n                Entry<LifecycleObserver, ObserverWithState> entry = ascendingIterator.next();\r\n                ObserverWithState observer = entry.getValue();\r\n                while ((observer.mState.compareTo(mState) < 0 && !mNewEventOccurred\r\n                        && mObserverMap.contains(entry.getKey()))) {\r\n                    pushParentState(observer.mState);\r\n                    // 分发状态改变事件\r\n                    observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));\r\n                    popParentState();\r\n                }\r\n            }\r\n        }\r\n    \r\n        /**\r\n         * 向后传递事件，对应图中的RESUMED -> DESTROYED\r\n         * 减小Observer的状态值，直到状态值等于当前状态值\r\n         */\r\n        private void backwardPass(LifecycleOwner lifecycleOwner) {\r\n            Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =\r\n                    mObserverMap.descendingIterator();\r\n            while (descendingIterator.hasNext() && !mNewEventOccurred) {\r\n                Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();\r\n                ObserverWithState observer = entry.getValue();\r\n                while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred\r\n                        && mObserverMap.contains(entry.getKey()))) {\r\n                    Event event = downEvent(observer.mState);\r\n                    // 分发状态改变事件\r\n                    pushParentState(getStateAfter(event));\r\n                    observer.dispatchEvent(lifecycleOwner, event);\r\n                    popParentState();\r\n                }\r\n            }\r\n        }\r\n    \r\n\r\n`LifecycleRegistry`代码我门看完了，注释也已经很清楚了，基本作用就是添加观察者，响应生命周期事件，分发生命周期事件的作用。\r\n\r\n  \r\n\r\n3.3 ReportFragment\r\n------------------\r\n\r\n接下来我们继续分析`ComponentActivity`，我们在`onCreate()`声明周期中发现一个比较熟悉`ReportFragment`，这个fragment我以前在做内存泄漏优化的时候经常碰到，在leakcanary中经常会报出这个类，所以这里面看看`ReportFragment.injectIfNeededIn(this);`到底做了什么？\r\n\r\n    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)\r\n    public class ReportFragment extends Fragment {\r\n        private static final String REPORT_FRAGMENT_TAG = \"androidx.lifecycle\"\r\n                + \".LifecycleDispatcher.report_fragment_tag\";\r\n    \r\n        public static void injectIfNeededIn(Activity activity) {\r\n            // ProcessLifecycleOwner should always correctly work and some activities may not extend\r\n            // FragmentActivity from support lib, so we use framework fragments for activities\r\n            android.app.FragmentManager manager = activity.getFragmentManager();\r\n            if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\r\n                manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\r\n                // Hopefully, we are the first to make a transaction.\r\n                manager.executePendingTransactions();\r\n            }\r\n        }\r\n        private void dispatchCreate(ActivityInitializationListener listener) {\r\n            if (listener != null) {\r\n                listener.onCreate();\r\n            }\r\n        }\r\n    \r\n        private void dispatchStart(ActivityInitializationListener listener) {\r\n            if (listener != null) {\r\n                listener.onStart();\r\n            }\r\n        }\r\n    \r\n        private void dispatchResume(ActivityInitializationListener listener) {\r\n            if (listener != null) {\r\n                listener.onResume();\r\n            }\r\n        }\r\n    \r\n        @Override\r\n        public void onActivityCreated(Bundle savedInstanceState) {\r\n            super.onActivityCreated(savedInstanceState);\r\n            dispatchCreate(mProcessListener);\r\n            dispatch(Lifecycle.Event.ON_CREATE);\r\n        }\r\n    \r\n        @Override\r\n        public void onStart() {\r\n            super.onStart();\r\n            dispatchStart(mProcessListener);\r\n            dispatch(Lifecycle.Event.ON_START);\r\n        }\r\n    \r\n        @Override\r\n        public void onResume() {\r\n            super.onResume();\r\n            dispatchResume(mProcessListener);\r\n            dispatch(Lifecycle.Event.ON_RESUME);\r\n        }\r\n    \r\n        @Override\r\n        public void onPause() {\r\n            super.onPause();\r\n            dispatch(Lifecycle.Event.ON_PAUSE);\r\n        }\r\n    \r\n        @Override\r\n        public void onStop() {\r\n            super.onStop();\r\n            dispatch(Lifecycle.Event.ON_STOP);\r\n        }\r\n    \r\n        @Override\r\n        public void onDestroy() {\r\n            super.onDestroy();\r\n            dispatch(Lifecycle.Event.ON_DESTROY);\r\n            // just want to be sure that we won't leak reference to an activity\r\n            mProcessListener = null;\r\n        }\r\n    \r\n        private void dispatch(Lifecycle.Event event) {\r\n            Activity activity = getActivity();\r\n            if (activity instanceof LifecycleRegistryOwner) {\r\n                ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\r\n                return;\r\n            }\r\n    \r\n            if (activity instanceof LifecycleOwner) {\r\n                Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\r\n                if (lifecycle instanceof LifecycleRegistry) {\r\n                    ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\r\n                }\r\n            }\r\n        }\r\n    \r\n\r\n查看源码我们发现，`ReportFragment`在每个生命周期中都做了分发事件的处理，通过调用`getLifecycle().handleLifecycleEvent(event)`来做生命周期的分发。意思也就是在`ComponentActivity`中添加了一个没有页面的`ReportFragment`，当Activity生命周期变化的时候，通过调用`LifecycleRegistry.handleLifecycleEvent()`方法通知LifecycleRegistry改变状态，LifecycleRegistry内部调用`moveToState()`改变状态，并调用每个LifecycleObserver.onStateChange()方法通知生命周期变化。\r\n\r\n> 我们通过查看ReportFragment调用，发现还有两个类也调用了它，一个是`LifecycleDispatcher`，一个是`ProcessLifecycleOwner`，这两个究竟是做什么的呢？\r\n\r\n\\[外链图片转存失败(img-Kmu4o9EL-1562754821909)([http://psv0rasgi.bkt.clouddn.com/jetpack/_image/2019-06-10/屏幕快照 2019-06-11 下午2.19.20 (2).png#align=left&display=inline&height=324&originHeight=648&originWidth=1112&status=done&width=556](http://psv0rasgi.bkt.clouddn.com/jetpack/_image/2019-06-10/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-11%20%E4%B8%8B%E5%8D%882.19.20%20%282%29.png#align=left&display=inline&height=324&originHeight=648&originWidth=1112&status=done&width=556))\\]\r\n\r\n  \r\n\r\n3.4 LifecycleDispatcher\r\n-----------------------\r\n\r\n    class LifecycleDispatcher {\r\n    \r\n        private static AtomicBoolean sInitialized = new AtomicBoolean(false);\r\n    \r\n        static void init(Context context) {\r\n            if (sInitialized.getAndSet(true)) {\r\n                return;\r\n            }\r\n            ((Application) context.getApplicationContext())\r\n                    .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());\r\n        }\r\n    \r\n        @SuppressWarnings(\"WeakerAccess\")\r\n        @VisibleForTesting\r\n        static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {\r\n    \r\n            @Override\r\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\r\n                ReportFragment.injectIfNeededIn(activity);\r\n            }\r\n    \r\n            @Override\r\n            public void onActivityStopped(Activity activity) {\r\n            }\r\n    \r\n            @Override\r\n            public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\r\n            }\r\n        }\r\n    \r\n        private LifecycleDispatcher() {\r\n        }\r\n    }\r\n    \r\n\r\n我们查看源码，发现在`init()`方法中，通过`Application`注册了`DispatcherActivityCallback`，并且在`onActivityCreated`中将`ReportFragment`注入到Activity中。\r\n\r\n  \r\n\r\n3.5 ProcessLifecycleOwner\r\n-------------------------\r\n\r\n    public class ProcessLifecycleOwner implements LifecycleOwner {\r\n    \r\n           private final LifecycleRegistry mRegistry = new LifecycleRegistry(this);\r\n    \r\n        private Runnable mDelayedPauseRunnable = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                dispatchPauseIfNeeded();\r\n                dispatchStopIfNeeded();\r\n            }\r\n        };\r\n    \r\n        private ActivityInitializationListener mInitializationListener =\r\n                new ActivityInitializationListener() {\r\n                    @Override\r\n                    public void onCreate() {\r\n                    }\r\n    \r\n                    @Override\r\n                    public void onStart() {\r\n                        activityStarted();\r\n                    }\r\n    \r\n                    @Override\r\n                    public void onResume() {\r\n                        activityResumed();\r\n                    }\r\n                };\r\n    \r\n        private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();\r\n    \r\n       \r\n        public static LifecycleOwner get() {\r\n            return sInstance;\r\n        }\r\n    \r\n        static void init(Context context) {\r\n            sInstance.attach(context);\r\n        }\r\n    \r\n        void activityStarted() {\r\n            mStartedCounter++;\r\n            if (mStartedCounter == 1 && mStopSent) {\r\n                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);\r\n                mStopSent = false;\r\n            }\r\n        }\r\n    \r\n        void activityResumed() {\r\n            mResumedCounter++;\r\n            if (mResumedCounter == 1) {\r\n                if (mPauseSent) {\r\n                    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);\r\n                    mPauseSent = false;\r\n                } else {\r\n                    mHandler.removeCallbacks(mDelayedPauseRunnable);\r\n                }\r\n            }\r\n        }\r\n    \r\n       ......\r\n        private void dispatchStopIfNeeded() {\r\n            if (mStartedCounter == 0 && mPauseSent) {\r\n                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);\r\n                mStopSent = true;\r\n            }\r\n        }\r\n    \r\n        private ProcessLifecycleOwner() {\r\n        }\r\n        //监听Application生命周期，并分发给Activity\r\n        void attach(Context context) {\r\n            mHandler = new Handler();\r\n            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\r\n            Application app = (Application) context.getApplicationContext();\r\n            app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {\r\n                @Override\r\n                public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\r\n                    ReportFragment.get(activity).setProcessListener(mInitializationListener);\r\n                }\r\n    \r\n                @Override\r\n                public void onActivityPaused(Activity activity) {\r\n                    activityPaused();\r\n                }\r\n    \r\n                @Override\r\n                public void onActivityStopped(Activity activity) {\r\n                    activityStopped();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \r\n\r\n根据官方注释，我们可以了解到：\r\n\r\n*   ProcessLifecycleOwner是用来监听Application生命周期的，因此它只会分发一次ON\\_CREATE事件，并且不会分发ON\\_DESTROY事件。\r\n*   ProcessLifecycleOwner在Activity的onResume和onStop方法中都采用了Handle.postDelayed()方法，是为了处理Activity重建时比如横竖屏幕切换时，不会发送事件。\r\n*   ProcessLifecycleOwner一般用来判断应用是在前台还是后台。但由于使用了Handle.postDelayed()，因此这个判断不是即时的，有默认700ms的延迟。\r\n*   ProcessLifecycleOwner与LifecycleDispatcher一样，都是通过注册Application.registerActivityLifecycleCallbacks来监听Activity的生命周期回调，来给每个Activity添加ReportFragment的。\r\n\r\n看了着两个类我们发现它们的入口均为`init()`,所以看一下谁调用了？\r\n\r\n  \r\n\r\n3.6 ProcessLifecycleOwnerInitializer\r\n------------------------------------\r\n\r\n    public class ProcessLifecycleOwnerInitializer extends ContentProvider {\r\n        @Override\r\n        public boolean onCreate() {\r\n            LifecycleDispatcher.init(getContext());\r\n            ProcessLifecycleOwner.init(getContext());\r\n            return true;\r\n        }\r\n    \r\n        @Nullable\r\n        @Override\r\n        public Cursor query(@NonNull Uri uri, String[] strings, String s, String[] strings1,\r\n                String s1) {\r\n            return null;\r\n        }\r\n    \r\n        @Nullable\r\n        @Override\r\n        public String getType(@NonNull Uri uri) {\r\n            return null;\r\n        }\r\n    \r\n        @Nullable\r\n        @Override\r\n        public Uri insert(@NonNull Uri uri, ContentValues contentValues) {\r\n            return null;\r\n        }\r\n    \r\n        @Override\r\n        public int delete(@NonNull Uri uri, String s, String[] strings) {\r\n            return 0;\r\n        }\r\n    \r\n        @Override\r\n        public int update(@NonNull Uri uri, ContentValues contentValues, String s, String[] strings) {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n\r\n果真，在`ProcessLifecycleOwnerInitializer` 的`onCreate()`中对这两个进行了初始化，看类名可以翻译成_进程生命周期初始化_，到这里我们对该类就找不到调用者或者使用者了，所以不得不百度一下，发现有人说这个类是在`AndroidManifest.xml`中声明的，在构建APK过程中，AS会将多个模块的`AndroidManifest.xml`合并到一起，所以查看build目录，具体路径为`build/intermediates/bundle_manifest/debug/processDebugManifest/bundle-manifest/AndroidManifest.xml`，果真在里面：\r\n\r\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n    <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n        package=\"com.hankkin.reading_aac\"\r\n        android:versionCode=\"1\"\r\n        android:versionName=\"1.0\" >\r\n    \r\n        <uses-sdk\r\n            android:minSdkVersion=\"19\"\r\n            android:targetSdkVersion=\"28\" />\r\n    \r\n        <application\r\n            android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\"\r\n            android:debuggable=\"true\"\r\n            android:icon=\"@mipmap/ic_launcher\"\r\n            android:label=\"@string/app_name\"\r\n            android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n            android:supportsRtl=\"true\"\r\n            android:testOnly=\"true\"\r\n            android:theme=\"@style/AppTheme\" >\r\n            <activity android:name=\"com.hankkin.reading_aac.ui.LoginActivity\" >\r\n            </activity>\r\n            <activity android:name=\"com.hankkin.reading_aac.MainActivity\" >\r\n                <intent-filter>\r\n                    <action android:name=\"android.intent.action.MAIN\" />\r\n    \r\n                    <category android:name=\"android.intent.category.LAUNCHER\" />\r\n                </intent-filter>\r\n            </activity>\r\n    \r\n            <provider\r\n                android:name=\"androidx.lifecycle.ProcessLifecycleOwnerInitializer\"\r\n                android:authorities=\"com.hankkin.reading_aac.lifecycle-process\"\r\n                android:exported=\"false\"\r\n                android:multiprocess=\"true\" />\r\n        </application>\r\n    \r\n    </manifest>\r\n    \r\n\r\n到这里整个Lifecycle初始化的过程就结束了。\r\n\r\n  \r\n\r\n4\\. 总结\r\n======\r\n\r\n经过上面的源码分析，我们可以大概给整个**Lifecycle组件**分为三部分：\r\n\r\n  \r\n\r\n4.1 Lifecycle的初始化\r\n-----------------\r\n\r\n    通过在manifest中声明provider，`ProcessLifecycleOwnerInitializer`注册Activity和fragment.的声明周期回调并做监听，同时向Activity中添加一个空白的`ReportFragment`，使用它作为生命周期的事件分发。而当Activity和Fragment生命周期状态发生改变时，都通过LifecycleRegistryOwner来处理生命周期状态的改变。\r\n    \r\n\r\n  \r\n\r\n4.2 Lifecycle的状态改变及状态分发\r\n-----------------------\r\n\r\n    在`ReportFragment`中调用`LifecycleRegister.handleLifecycleEvent(Lifecycle.Event)`，通过**获取事件对应的下一个状态**以及**改变当前状态到下一个状态**，同步分发事件；最后将各个观察者的生命周期状态依次移动到正确状态。\r\n    \r\n\r\n可以查看下面的时序图：\r\n\r\n![](https://img-blog.csdn.net/20180922213240512?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpZXpoaWh1YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70#align=left&display=inline&height=185&originHeight=185&originWidth=703&status=done&width=703)\r\n\r\n  \r\n\r\n4.3 Lifecycle解析生命周期\r\n-------------------\r\n\r\n我们声明的**MyObserver**中的方法都是带有注解的，查看`OnLifecycleEvent`：\r\n\r\n    @Retention(RetentionPolicy.RUNTIME)\r\n    @Target(ElementType.METHOD)\r\n    public @interface OnLifecycleEvent {\r\n        Lifecycle.Event value();\r\n    }\r\n    \r\n\r\n注解修饰的方法会通过反射的方式获取，并且保存在`ClassesInfoCache`中，然后在生命周期发生改变的时候再找到对应 Event 的方法，通过反射来调用方法。\r\n\r\n  \r\n\r\n5\\. 参考链接：\r\n=========\r\n\r\n[https://juejin.im/post/5cd81634e51d453af7192b87#heading-10](https://juejin.im/post/5cd81634e51d453af7192b87#heading-10)\r\n\r\nhttps://yuqirong.me/2018/07/15/Android%20Architecture%20Component%E4%B9%8BLifecycle%E8%A7%A3%E6%9E%90/",
      "data": {
        "title": "[转载] 3. Jetpack源码解析---用Lifecycles管理生命周期",
        "date": "2019-10-15 17:09:17",
        "tags": [
          "转载"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/91440191](https://blog.csdn.net/lyhhj/article/details/91440191)\r",
      "fileName": "zhuan-zai-3-jetpack-yuan-ma-jie-xi-yong-lifecycles-guan-li-sheng-ming-zhou-qi"
    },
    {
      "content": "## GsonFormat \r\n将json字符串转换成一个Java Bean\r\n\r\n## JsonToKotlin\r\n将json字符串转换成一个Java Bean\r\n\r\n## findViewByMe\r\n快速自动生成findViewById\r\n\r\n## JsonOnlineViewer\r\n在Android Studio中请求、调试接口。 \r\n\r\n## GradleDependencyHelper\r\nmaven gradle 依赖支持自动补全插件。 \r\n\r\n## jimu Mirror\r\n一个可以让你在真实的设备上迅速测试布局的插件。jimu Mirror允许在设备上预览随同编码更新的Android布局。\r\n\r\n## Drawable Importer\r\n添加了一个在不同分辨率导入画板或缩放指定图像到定义分辨率的选项\r\n\r\n## AndroidProguardPlugin\r\n一键生成项目混淆代码插件，值得你安装。 \r\n\r\n## folding-plugin\r\n布局文件分组的插件。 \r\n\r\n## AndroidLocalizationer\r\n可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件。\r\n\r\n## PermissionsDispatcher plugin\r\n自动生成6.0权限的代码。 \r\n\r\n## AndroidPixelDimenGenerator\r\nAndroid Studio自动生成dimen.xml文件插件。\r\n\r\n## adb wifi\r\n使用wifi无线调试你的app，无需root权限。\r\n\r\n# findBugs-IDEA\r\n查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…）\r\n\r\n## Android Parcelable code generator\r\nParcelable是Android实体类的一种实例化方式。 \r\n\r\n## ApkMultiChannelPlugin\r\n这是一个为了方便 Android 多渠道打包的 Android Studio / IDEA 插件\r\n\r\n## lint-cleaner-plugin\r\n移除Android中无用资源\r\n\r\n## Translation\r\n翻译\r\n\r\n## findBugs\r\n查找bug的插件\r\n",
      "data": {
        "title": "Android Studio常用插件",
        "date": "2019-10-10 11:21:56",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "android-studio-chang-yong-cha-jian"
    },
    {
      "content": " 记得无论怎么转载，都要注明“转载”并且说明出处一定要选择【转载】，尊重原创！！\r\n\r\n<!-- more -->\r\n\r\n在浏览器打开文章，右键 -> 检查,或者直接F12看html代码\r\n![](https://ouluqiang.github.io//post-images/1570441106069.png)\r\n\r\n再复制文章内容的代码\r\n![](https://ouluqiang.github.io//post-images/1570441466035.png)\r\n\r\n将html直接粘贴到markdown也是可以的，但是我发现代码块的样式会乱掉，所以可以先将html转换成md，[https://tool.lu/markdown/](https://tool.lu/markdown/)\r\n![](https://ouluqiang.github.io//post-images/1570441613122.png)\r\n\r\n",
      "data": {
        "title": "转载文章",
        "date": "2019-10-07 17:32:45",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": " 记得无论怎么转载，都要注明“转载”并且说明出处一定要选择【转载】，尊重原创！！\r",
      "fileName": "zhuan-zai-wen-zhang"
    },
    {
      "content": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/93757755](https://blog.csdn.net/lyhhj/article/details/93757755)\r\n\r\n<!-- more -->\r\n\r\n1\\. 背景\r\n======\r\n\r\n> 之前已经翻译过了Google官方的CodeLabs上面的教程，教程很详细，代码在Github上也可以找到，本篇文章旨在自己的APP上使用效果及演示Demo，来具体的使用Navigation。并且对其进行源码解析。\r\n\r\n基本相关介绍可以查看我之前翻译的文章，基本就是google翻译了一个大概。\r\n\r\n[一、Android Jetpack\\_Note\\_CodeLabs一Navigation](https://juejin.im/post/5cf37caee51d45777621bb2b)\r\n\r\n2\\. 基本使用\r\n========\r\n\r\n> 虽然在之前的文章中已经很详细的介绍了`Navigation`，但是这里也简单的叙述一下我在项目中的具体使用：\r\n\r\n2.1 Navigation+DrawerLayout+ToolBar\r\n-----------------------------------\r\n\r\n我们可以通过使用`Navigation` 配合`DrawerLayout`侧边栏和`Toolbar`标题来进行工作，不再需要我们去定义点击事件，也不需要我们去管理Fragment做切换，只需要我们做相关的配置和极少量的代码就可以了。\r\n\r\n### 2.1.1 DrawerLayout\r\n\r\n侧边栏的用法和我们之前的使用一样，配置好我们`NavigationView`里面的`_headerLayout_`_、_`_menu_`_即可；_\r\n\r\n> **注意：**这里面的menu有一点和我们之前的不一样，item的id必须要和navigation里面的fragment的id相同，否则点击事件不生效，这里先提一下，下面会详细介绍。\r\n\r\n### 2.1.2 ToolBar和NavHostFragment\r\n\r\n`DrawerLayout`配置好之后，我们再来配置标题栏，之前我们的用法都是在中间加一个存放`Fragment`的容器，有可能是`FrameLayout`、`ViewPager`等，这里面我们需要配置一个`Fragment`，这个`Fragment`的**name**是`androidx.navigation.fragment.NavHostFragment`，这是一个添加到布局中的特殊部件，**NavHostFragment**通过**navGraph**与**navigation**导航编辑器进行关联。具体代码如下：\r\n\r\n    <androidx.drawerlayout.widget.DrawerLayout\r\n                xmlns:tools=\"http://schemas.android.com/tools\"\r\n                android:id=\"@+id/drawer_layout\"\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"match_parent\"\r\n                android:fitsSystemWindows=\"true\"\r\n                tools:openDrawer=\"start\">\r\n            <LinearLayout\r\n                    android:layout_width=\"match_parent\"\r\n                    android:layout_height=\"match_parent\"\r\n                    android:orientation=\"vertical\">\r\n                <com.google.android.material.appbar.AppBarLayout\r\n                        android:layout_height=\"wrap_content\"\r\n                        android:layout_width=\"match_parent\"\r\n                        android:theme=\"@style/AppTheme.AppBarOverlay\">\r\n    \r\n                    <androidx.appcompat.widget.Toolbar\r\n                            android:id=\"@+id/toolbar\"\r\n                            android:layout_width=\"match_parent\"\r\n                            android:layout_height=\"?attr/actionBarSize\"\r\n                            android:background=\"?attr/colorPrimary\"\r\n                            android:theme=\"@style/AppTheme.PopupOverlay\"\r\n                    />\r\n    \r\n                </com.google.android.material.appbar.AppBarLayout>\r\n    \r\n                <fragment\r\n                        android:id=\"@+id/fragment_home\"\r\n                        android:name=\"androidx.navigation.fragment.NavHostFragment\"\r\n                        android:layout_width=\"match_parent\"\r\n                        android:layout_height=\"match_parent\"\r\n                        app:defaultNavHost=\"true\"\r\n                        app:navGraph=\"@navigation/navigation_main\"/>\r\n            </LinearLayout>\r\n    \r\n            <com.google.android.material.navigation.NavigationView\r\n                    app:itemIconTint=\"@color/nav_item_txt\"\r\n                    app:itemTextColor=\"@color/nav_item_txt\"\r\n                    android:id=\"@+id/nav_view\"\r\n                    android:layout_width=\"wrap_content\"\r\n                    android:layout_height=\"match_parent\"\r\n                    android:layout_gravity=\"start\"\r\n                    android:fitsSystemWindows=\"true\"\r\n                    app:headerLayout=\"@layout/nav_header_main\"\r\n                    app:menu=\"@menu/activity_main_drawer\"/>\r\n    \r\n        </androidx.drawerlayout.widget.DrawerLayout>\r\n    \r\n\r\n我们可以看到**NavHostFragment**中有两个属性比较特殊：`app:defaultNavHost`和`app:navGraph=\"@navigation/navigation_main\"`，前者就是是否是默认的其实页面，后者就是我们要设计的Navigation布局文件.\r\n\r\n### 2.1.3 navigation_main.xml\r\n\r\n在`Android Studio`3.2版本以上里面内嵌了`Navigation`的设计面板工具，我们可以在res文件夹下面的`navigation`文件里面对我们的fragment/Activity进行设计。\r\n\r\n![WeChatf84276a636246413fd559699a8c1e759.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk1NTM0NzQ3ODMtNzBlMGI3ODItNDNlYy00YTE3LTkyZTYtZTZkOWZmMDZmOTljLnBuZw#align=left&display=inline&height=152&name=WeChatf84276a636246413fd559699a8c1e759.png&originHeight=202&originWidth=546&size=27542&status=done&width=410)\r\n\r\n打开**Desgin**面板，进入设计模式，在里面我们可以新建我们的目标页面。如果你还没创建过一个\\*\\*Destination，\\*\\*你可以点击`create a destination`创建一个`Fragmengt/Activity`。当然如果你之前已经创建好了的话，在这里你可以直接选择：\r\n\r\n![WeChat224344cdf31a9c4010f08da7cdf8f45e.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk1NTM3MDU4ODQtNDNkYTg1ZGMtNmQ0OC00NmY0LWFmMjktOGRkZDQwMTZhZmVkLnBuZw#align=left&display=inline&height=429&name=WeChat224344cdf31a9c4010f08da7cdf8f45e.png&originHeight=858&originWidth=1196&size=147391&status=done&width=598)\r\n\r\n选择完一个**Destination**之后，在面板中就可以看到了，具体的action、arguments就不介绍了，详细的可以看之前的文章。\r\n\r\n打开**Text**模式的xml我们可以看到我们选择的Fragmengt配置信息，当然你也可以不通过面板设计，也可以直接在xml里进行代码编写。  \r\n`startDestination`是APP默认启动的页面，这里面必须要指定，否则会报错crash。这里我的代码所指默认页面是`HomeFragment`，如下：\r\n\r\n    <navigation xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n                xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n                xmlns:tools=\"http://schemas.android.com/tools\"\r\n                android:id=\"@+id/navigation_main\"\r\n                app:startDestination=\"@+id/homeFragment\"\r\n                tools:ignore=\"UnusedNavigation\">\r\n      \r\n     <fragment android:id=\"@+id/homeFragment\"\r\n                  android:name=\"com.hankkin.jetpack_note.ui.home.HomeFragment\"\r\n                  android:label=\"@string/menu_home\">\r\n            <action android:id=\"@+id/action_navigationFragment_to_webFragment\"\r\n                    app:destination=\"@id/webFragment\"\r\n                    app:enterAnim=\"@anim/slide_in_right\"\r\n                    app:exitAnim=\"@anim/slide_out_left\"\r\n                    app:popEnterAnim=\"@anim/slide_in_left\"\r\n                    app:popExitAnim=\"@anim/slide_out_right\"/>\r\n        </fragment>\r\n    \r\n        <fragment android:id=\"@+id/codeFragment\"\r\n                  android:name=\"com.hankkin.jetpack_note.ui.CodeFragment\"\r\n                  android:label=\"@string/menu_code\"/>\r\n    \r\n\r\n我们可以看到上面的布局代码 默认的起始页面是homeFragment，下面还有一个codeFragment，其实这两个fragment也就是对应着在menu中的两个菜单，同时也对应我们侧边栏中的一个**首页**和一个**代码页，**\r\n\r\n    <item\r\n                    android:id=\"@+id/homeFragment\"\r\n                    android:icon=\"@drawable/ic_menu_home\"\r\n                    android:title=\"@string/menu_home\"/>\r\n            <item\r\n                    android:id=\"@+id/codeFragment\"\r\n                    android:icon=\"@drawable/ic_menu_code\"\r\n                    android:title=\"@string/menu_code\"/>\r\n    \r\n\r\n> 还记得上面说的id要相同吗？就是上面**item的id**要和**navigation_main.xml**中fragment的id相同，否则点击菜单不会切换fragment的。\r\n\r\n配置完上面这些信息之后，怎么将他们绑定起来使用呢？\r\n\r\n### 2.1.4 NavController\r\n\r\n先看下代码：\r\n\r\n    \t\tnavController = Navigation.findNavController(this, R.id.fragment_home)\r\n            appBarConfiguration = AppBarConfiguration(setOf(R.id.homeFragment, R.id.codeFragment), drawerLayout)\r\n            // Set up ActionBar\r\n            setSupportActionBar(mDataBinding.toolbar)\r\n            setupActionBarWithNavController(navController, appBarConfiguration)\r\n            // Set up navigation menu\r\n            mDataBinding.navView.setupWithNavController(navController)\r\n    \r\n\r\n*   我们通过findNavController传入之前定义好的装载fragment的容器id（也就是之前定义的NavHostFragment）找到了Navigation对应的navController；\r\n*   通过配置一个AppBarConfiguration，AppBarConfiguration 里传入了一个id的set集合和drawerlayout，id的集合就是我们在\\*\\*navigation_main.xml \\*\\*定义的fragment id\r\n*   最后通过设置setupActionBarWithNavController、setupWithNavController进行关联绑定\r\n\r\n> 到此，我们的基本配置就结束了，可以看到我们drawerlayout中的首页和代码按钮点击会切换对应的fragment，同时toolbar的汉堡按钮和返回按钮也会自动切换；当然Navigation还可以配合BottomNavigationView使用。\r\n\r\n2.2 BottomNavigationView使用\r\n--------------------------\r\n\r\n### 2.2.1 配置文件\r\n\r\n和上面的步骤类似：也是配置好 navigation.xml布局以及 BottomNavigationView所对应的menu菜单文件  \r\n\r\n### 2.2.2 setupWithNavController\r\n\r\n当然BottomNavigationView也提供了扩展方法setupWithNavController去绑定菜单和fragment，这里使用很简单就不具体介绍了。详情可见[BottomNavSampleActivity](https://github.com/Hankkin/JetPack_Note/blob/master/app/src/main/java/com/hankkin/jetpack_note/ui/navigation/BottomNavSampleActivity.kt)。\r\n\r\n2.3 Action跳转及传餐\r\n---------------\r\n\r\n### 2.3.1 Action跳转\r\n\r\n先看一下navigation的Desgin模式：\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk2MzQ4MzIwNDUtMTZmYzY0ZWItOTI3MS00MTAwLWEyOTMtM2I4MDg5M2UzMWEzLnBuZw#align=left&display=inline&height=348&name=image.png&originHeight=695&originWidth=747&size=159060&status=done&width=374)\r\n\r\n可能你会注意到这些线是什么？没错这就是一个一个的**Action**，当你手动将两个Fragment进行连线后，在xml布局里面会对应生成一个标签，例如：\r\n\r\n    <action android:id=\"@+id/action_dashBoardSampleFragment_to_notificationSampleFragment\"\r\n                    app:destination=\"@id/notificationSampleFragment\"/>\r\n    \r\n\r\n  \r\n它会自动创建好id，id有可能比较长，但是确很清楚，从xtoy的模式，当然如果你不喜欢可以自己改，destination则是我们要跳转到的目标接界面。\r\n\r\naction设置好了之后，我们可以执行下面代码进行跳转：\r\n\r\n    findNavController().navigate(R.id.action_homeSampleFragment_to_dashBoardSampleFragment_action)\r\n    \r\n\r\n### 2.3.2 NavOptions切换动画\r\n\r\n当然fragment之间的切换是支持动画的，NavOptions是一个动画管理类，我们可以设置进入和回退的动画，设置的方式有两种：\r\n\r\n1.  直接在标签中设置动画\r\n\r\n    <action android:id=\"@+id/action_homeSampleFragment_to_dashBoardSampleFragment_action\"\r\n                    app:destination=\"@id/dashBoardSampleFragment\"\r\n                    app:enterAnim=\"@anim/slide_in_right\"\r\n                    app:exitAnim=\"@anim/slide_out_left\"\r\n                    app:popEnterAnim=\"@anim/slide_in_left\"\r\n                    app:popExitAnim=\"@anim/slide_out_right\"/>\r\n    \r\n\r\n2.  通过NavOptions设置动画\r\n\r\n    val options = navOptions {\r\n                anim {\r\n                    enter = R.anim.slide_in_right\r\n                    exit = R.anim.slide_out_left\r\n                    popEnter = R.anim.slide_in_left\r\n                    popExit = R.anim.slide_out_right\r\n                }\r\n            }\r\n            view.findViewById < Button >(R.id.navigate_destination_button)?.setOnClickListener {\r\n                findNavController().navigate(R.id.flow_step_one_dest, null, options)\r\n            }\r\n    \r\n\r\n### 2.3.3 参数传递\r\n\r\nfragment之间的切换参数传递的方法也很简单，之前我们可能要通过宿主Activity或者接口等方法，总之挺麻烦的，下面我们看看通过Navigation控制的Fragment之间怎么传递？\r\n\r\n我们可以在naviagtion布局中使用标签，\r\n\r\n*   name是我们传参的key\r\n*   argType是参数类型\r\n*   defaultValue默认值\r\n*   nullable 是否可空\r\n\r\n    <argument\r\n             android:name=\"deep_args\"\r\n             app:argType=\"\"\r\n             android:defaultValue=\"\"\r\n             app:nullable=\"\"/>\r\n    \r\n\r\n> **注意：**当然type类型也支持我们自定的实体类，但是需要你填写类的全路径，同时你要保证实体类实现了序列化\r\n\r\n我们可以通过把参数传递封装到Bundle中，然后再执行navigate()方法时传递过去，例如：\r\n\r\n    val args = Bundle()\r\n    args.putString(\"link\",\"1\")\r\n    args.putString(\"title\",\"1\")\r\n    it.findNavController().navigate(R.id.webFragment, args)\r\n    \r\n\r\n当然你在接受是也可以通过getArguments().getString(xxxx)这种方式去获取，但是Navigation组件还提供给了我们更简单的方式，当你设置了标签后，通过编译代码，会自动为我们生成一个**XXXFragmentDirections**类，它里面为我们作了参数的封装，而NavController的navigate()方法同时支持direction类型的传递。\r\n\r\n    val direction = HomeFragmentDirections.actionNavigationFragmentToWebFragment(link,title)\r\n    it.findNavController().navigate(direction)\r\n    \r\n\r\n同时在我们的目标页面所对应了一个XXXFragmentArgs，我们可以直接拿到navArgs()从这里我们可以直接拿到参数。\r\n\r\n    private val args: WebFragmentArgs by navArgs()\r\n    \r\n\r\n2.4 Deep Link\r\n-------------\r\n\r\n关于Deep Link 是指跳入应用内的一个功能，我就把它翻译成深层链接了，Navigation提供了这样一个功能，使用起来也很简单：\r\n\r\n                val args = Bundle()\r\n                args.putString(\"deep_args\",et_deep_link.text.toString())\r\n                val deep = findNavController().createDeepLink()\r\n                    .setDestination(R.id.notificationSampleFragment)\r\n                    .setArguments(args)\r\n                    .createPendingIntent()\r\n    \r\n                val notificationManager =\r\n                    context?.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\r\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                    notificationManager.createNotificationChannel(\r\n                        NotificationChannel(\r\n                            \"deeplink\", \"Deep Links\", NotificationManager.IMPORTANCE_HIGH)\r\n                    )\r\n                }\r\n                val builder = NotificationCompat.Builder(\r\n                    context!!, \"deeplink\")\r\n                    .setContentTitle(resources.getString(R.string.app_name))\r\n                    .setContentText(\"Navigation 深层链接测试\")\r\n                    .setSmallIcon(R.mipmap.jetpack)\r\n                    .setContentIntent(deep)\r\n                    .setAutoCancel(true)\r\n                notificationManager.notify(0, builder.build())\r\n    \r\n\r\n我们可以创建一个DeepLink，带上参数，通过Notification通知来测试这样的效果，可以直接跳到项目中的该页面。  \r\n具体可查看[SampleNotificationFragment](https://github.com/Hankkin/JetPack_Note/blob/master/app/src/main/java/com/hankkin/jetpack_note/ui/navigation/SampleNotificationFragment.kt)。\r\n\r\n3\\. 源码解析\r\n========\r\n\r\n### 3.1 NavHostFragment\r\n\r\n> 官网上是这样介绍它的：NavHostFragment provides an area within your layout for self-contained navigation to occur. 大致意思就是NavHostFragment在布局中提供了一个区域，用于进行包含导航\r\n\r\n接下来我们看一下它的源码：\r\n\r\n    public class NavHostFragment extends Fragment implements NavHost {\r\n        @CallSuper\r\n        @Override\r\n        public void onAttach(@NonNull Context context) {\r\n            super.onAttach(context);\r\n            if (mDefaultNavHost) {\r\n                requireFragmentManager().beginTransaction()\r\n                        .setPrimaryNavigationFragment(this)\r\n                        .commit();\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n可以看到它就是一个`Fragment`，在`onAttach`生命周期开启事务将它自己设置成了PrimaryFragment了，当然通过`defaultNavHost`条件判断的，这个布尔值看着眼熟吗？没错，就是我们在xml布局中设置的那一个。\r\n\r\n    \t\t\t\t\t<fragment\r\n                        android:id=\"@+id/fragment_home\"\r\n                        android:name=\"androidx.navigation.fragment.NavHostFragment\"\r\n                        android:layout_width=\"match_parent\"\r\n                        android:layout_height=\"match_parent\"\r\n                        app:defaultNavHost=\"true\"\r\n                        app:navGraph=\"@navigation/navigation_main\"/>\r\n    \r\n\r\n接着看它的`onCreate`生命周期\r\n\r\n        @CallSuper\r\n        @Override\r\n        public void onCreate(@Nullable Bundle savedInstanceState) {\r\n            super.onCreate(savedInstanceState);\r\n            final Context context = requireContext();\r\n    \r\n            mNavController = new NavController(context);\r\n            mNavController.getNavigatorProvider().addNavigator(createFragmentNavigator());\r\n    \r\n           \t.......\r\n    \r\n            if (navState != null) {\r\n                // Navigation controller state overrides arguments\r\n                mNavController.restoreState(navState);\r\n            }\r\n            if (mGraphId != 0) {\r\n                // Set from onInflate()\r\n                mNavController.setGraph(mGraphId);\r\n            } else {\r\n                // See if it was set by NavHostFragment.create()\r\n                final Bundle args = getArguments();\r\n                final int graphId = args != null ? args.getInt(KEY_GRAPH_ID) : 0;\r\n                final Bundle startDestinationArgs = args != null\r\n                        ? args.getBundle(KEY_START_DESTINATION_ARGS)\r\n                        : null;\r\n                if (graphId != 0) {\r\n                    mNavController.setGraph(graphId, startDestinationArgs);\r\n                }\r\n            }\r\n        }\r\n    \r\n\r\n我们看到在`onCreate`生命周期中创建了一个`NavController`，并且为这个`NavController`创建了一个`_Navigator_`_添加了进去，_我们跟踪`createFragmentNavigator`，发现它创建了一个`FragmentNavigator`，这个类是做什么的呢？它继承了Navigator，查看注释我们知道它是为每个Navigation设置策略的，也就是说Fragment之间通过导航切换都是由它来操作的，下面会详细介绍的，这里先简单看下。  \r\n接下来我们看到为`NavController`设置了`setGraph()`，也就是我们xml里面定义的`navGraph`，导航布局里面的`Fragment`及`action`跳转等信息。\r\n\r\n还有就是onCreateView、onViewCreated等生命周期方法，基本就是加载布局设置ID的方法了。\r\n\r\n下面我们跟到NavController.setGraph()中看下是怎样将我们设计的fragment添加进去的？\r\n\r\n### 3.2 NavController\r\n\r\n    /**\r\n         * Sets the {@link NavGraph navigation graph} to the specified graph.\r\n         * Any current navigation graph data (including back stack) will be replaced.\r\n         *\r\n         * <p>The graph can be retrieved later via {@link #getGraph()}.</p>\r\n         *\r\n         * @param graph graph to set\r\n         * @see #setGraph(int, Bundle)\r\n         * @see #getGraph\r\n         */\r\n        @CallSuper\r\n        public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) {\r\n            if (mGraph != null) {\r\n                // Pop everything from the old graph off the back stack\r\n                popBackStackInternal(mGraph.getId(), true);\r\n            }\r\n            mGraph = graph;\r\n            onGraphCreated(startDestinationArgs);\r\n        }\r\n    \r\n\r\n我们看如果设置的graph不为null，它执行了popBackStackInternal，看注释的意思为从之前的就的graph栈弹出所有的graph：\r\n\r\n    boolean popBackStackInternal(@IdRes int destinationId, boolean inclusive) {\r\n            .....\r\n            .....\r\n            boolean popped = false;\r\n            for (Navigator navigator : popOperations) {\r\n                if (navigator.popBackStack()) {\r\n                    mBackStack.removeLast();\r\n                    popped = true;\r\n                } else {\r\n                    // The pop did not complete successfully, so stop immediately\r\n                    break;\r\n                }\r\n            }\r\n            return popped;\r\n        }\r\n    \r\n\r\n果真remove掉了之前所有的naviagtor。而这个mBackStack是什么时候添加的navigator的呢？查看源码我们发现：\r\n\r\n    private void navigate(@NonNull NavDestination node, @Nullable Bundle args,\r\n                @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {\r\n            boolean popped = false;\r\n            if (navOptions != null) {\r\n                if (navOptions.getPopUpTo() != -1) {\r\n                    popped = popBackStackInternal(navOptions.getPopUpTo(),\r\n                            navOptions.isPopUpToInclusive());\r\n                }\r\n            }\r\n            Navigator<NavDestination> navigator = mNavigatorProvider.getNavigator(\r\n                    node.getNavigatorName());\r\n            Bundle finalArgs = node.addInDefaultArgs(args);\r\n            NavDestination newDest = navigator.navigate(node, finalArgs,\r\n                    navOptions, navigatorExtras);\r\n            if (newDest != null) {\r\n                // 如果NavGraph不在栈内，先拿到父类Navgarph\r\n                ArrayDeque<NavBackStackEntry> hierarchy = new ArrayDeque<>();\r\n                NavGraph parent = newDest.getParent();\r\n                while (parent != null) {\r\n                    hierarchy.addFirst(new NavBackStackEntry(parent, finalArgs));\r\n                    parent = parent.getParent();\r\n                }\r\n                // 现在遍历后堆栈并查看哪些导航图已经在栈内\r\n                Iterator<NavBackStackEntry> iterator = mBackStack.iterator();\r\n                while (iterator.hasNext() && !hierarchy.isEmpty()) {\r\n                    NavDestination destination = iterator.next().getDestination();\r\n                    if (destination.equals(hierarchy.getFirst().getDestination())) {\r\n                        //destination 如果已经在栈顶，不需要再add了\r\n                        hierarchy.removeFirst();\r\n                    }\r\n                }\r\n                // Add all of the remaining parent NavGraphs that aren't\r\n                // already on the back stack\r\n                mBackStack.addAll(hierarchy);\r\n                //添加新的 destination\r\n                NavBackStackEntry newBackStackEntry = new NavBackStackEntry(newDest, finalArgs);\r\n                mBackStack.add(newBackStackEntry);\r\n            }\r\n            if (popped || newDest != null) {\r\n                dispatchOnDestinationChanged();\r\n            }\r\n        }\r\n    \r\n\r\n还记得这个方法吗？我们一般手动切换Fragment时可以调用这个方法，最后就是跟踪到这里。\r\n\r\n    findNavController().navigate(R.id.bottomNavSampleActivity)\r\n    \r\n\r\n同时，切换目标Fragment到栈顶。我们发现最后`dispatchOnDestinationChanged()`这个方法，分发目标界面切换。有必要去跟一下，你可能会发现意想不到的东西：\r\n\r\n     /**\r\n         * Dispatch changes to all OnDestinationChangedListeners.\r\n         * <p>\r\n         * If the back stack is empty, no events get dispatched.\r\n         *\r\n         * @return If changes were dispatched.\r\n         */\r\n        @SuppressWarnings(\"WeakerAccess\") /* synthetic access */\r\n        boolean dispatchOnDestinationChanged() {\r\n            // We never want to leave NavGraphs on the top of the stack\r\n            //noinspection StatementWithEmptyBody\r\n            while (!mBackStack.isEmpty()\r\n                    && mBackStack.peekLast().getDestination() instanceof NavGraph\r\n                    && popBackStackInternal(mBackStack.peekLast().getDestination().getId(), true)) {\r\n                // Keep popping\r\n            }\r\n            if (!mBackStack.isEmpty()) {\r\n                NavBackStackEntry backStackEntry = mBackStack.peekLast();\r\n                for (OnDestinationChangedListener listener :\r\n                        mOnDestinationChangedListeners) {\r\n                    listener.onDestinationChanged(this, backStackEntry.getDestination(),\r\n                            backStackEntry.getArguments());\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    \r\n\r\n这里面分发了所有实现了`OnDestinationChangedListener`接口的方法，继续跟踪，看看都哪些实现了这个接口呢？\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk2NjQwMDM5NDUtNGY2NWU4MjgtZWRlOC00M2VlLWI4NmItNjVlZmVkYzMwMTFhLnBuZw#align=left&display=inline&height=817&name=image.png&originHeight=817&originWidth=1941&size=315597&status=done&width=1941)\r\n\r\n只有一个类实现了**AbstractAppBarOnDestinationChangedListener**，看一下具体实现：\r\n\r\n    @Override\r\n        public void onDestinationChanged(@NonNull NavController controller,\r\n                @NonNull NavDestination destination, @Nullable Bundle arguments) {\r\n            DrawerLayout drawerLayout = mDrawerLayoutWeakReference != null\r\n                    ? mDrawerLayoutWeakReference.get()\r\n                    : null;\r\n            if (mDrawerLayoutWeakReference != null && drawerLayout == null) {\r\n                controller.removeOnDestinationChangedListener(this);\r\n                return;\r\n            }\r\n            CharSequence label = destination.getLabel();\r\n            if (!TextUtils.isEmpty(label)) {\r\n                ......\r\n                ......\r\n                matcher.appendTail(title);\r\n                //设置title\r\n                setTitle(title);\r\n            }\r\n            boolean isTopLevelDestination = NavigationUI.matchDestinations(destination,\r\n                    mTopLevelDestinations);\r\n            if (drawerLayout == null && isTopLevelDestination) {\r\n                //设置icon\r\n                setNavigationIcon(null, 0);\r\n            } else {\r\n                //设置返回箭头状态\r\n                setActionBarUpIndicator(drawerLayout != null && isTopLevelDestination);\r\n            }\r\n        }\r\n    \r\n\r\n原来如此，到这里就应该清楚了，当我们切换Fragment时，大概流程如下：\r\n\r\n1.  切换目标fragment到栈顶\r\n2.  分发目标Fragment切换状态\r\n3.  设置toolbar的标题、icon状态等\r\n4.  当然setTitle()、setNavigationIcon()等都为抽象方法，具体实现可以看子类里是怎么实现的，具体就不叙述了\r\n\r\n> 到这里，基本的几个核心类以及相关实现我们基本了解了，下面我们看一下基本的流程，首先我们从入口进去，一点点跟进\r\n\r\n### 3.3 Navigation.findNavController(this, R.id.fragment_home)\r\n\r\n我们在最开始会初始化一个NavController：\r\n\r\n    @NonNull\r\n        public static NavController findNavController(@NonNull Activity activity, @IdRes int viewId) {\r\n            View view = ActivityCompat.requireViewById(activity, viewId);\r\n            NavController navController = findViewNavController(view);\r\n            .......\r\n            return navController;\r\n        }\r\n    \r\n    @Nullable\r\n        private static NavController findViewNavController(@NonNull View view) {\r\n            while (view != null) {\r\n                NavController controller = getViewNavController(view);\r\n                .........\r\n            }\r\n            return null;\r\n        }\r\n    \r\n    @SuppressWarnings(\"unchecked\")\r\n        @Nullable\r\n        private static NavController getViewNavController(@NonNull View view) {\r\n            Object tag = view.getTag(R.id.nav_controller_view_tag);\r\n            NavController controller = null;\r\n            if (tag instanceof WeakReference) {\r\n                controller = ((WeakReference<NavController>) tag).get();\r\n            } else if (tag instanceof NavController) {\r\n                controller = (NavController) tag;\r\n            }\r\n            return controller;\r\n        }\r\n    \r\n\r\n查看代码可以看到是通过一个tag值来找到的，那么什么时候设置的呢？还记得3.1里面介绍的`NavHostFragment`的生命周期`onViewCreated`么？\r\n\r\n    @Override\r\n        public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\r\n            super.onViewCreated(view, savedInstanceState);\r\n            .......\r\n            View rootView = view.getParent() != null ? (View) view.getParent() : view;\r\n            Navigation.setViewNavController(rootView, mNavController);\r\n        }\r\n    \r\n\r\n在视图创建的时候调用了`Naviagtion.setViewNavController()`。NavController初始化好了之后，接下来将它和**NavigationView**、**ToolBar**、**BottomNavigationView**、**DrawerLayout**进行绑定：\r\n\r\n### 3.4 setupActionBarWithNavController\r\n\r\n不管是`NavigationView`还是`Bottom``NavigationView`，都会调用这个方法，他是`AppCompatActivity`的一个扩展方法，调用的是NavigationUI这个类：\r\n\r\n    public static void setupActionBarWithNavController(@NonNull AppCompatActivity activity,\r\n                @NonNull NavController navController,\r\n                @NonNull AppBarConfiguration configuration) {\r\n            navController.addOnDestinationChangedListener(\r\n                    new ActionBarOnDestinationChangedListener(activity, configuration));\r\n        }\r\n    \r\n\r\n可以看到它就是调用了目标切换的那个接口，用来实现标题按钮等状态的改变。查看它的方法实现：\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk2NjYyNjY1MjItMDFhOTc2YTEtN2I0Ni00OWMwLTljYzEtNmFlZjZjMjNlN2ZhLnBuZw#align=left&display=inline&height=697&name=image.png&originHeight=1393&originWidth=1151&size=265848&status=done&width=576)\r\n\r\n我们看到它重载了很多方法，包括我们上面提到的**NavigationView**、**ToolBar**、**BottomNavigationView**、**DrawerLayout**。这样就将组件的状态切换绑定起来了，当fragment切换时，上面提到的接口分发，去切换布局按钮等状态。\r\n\r\n### 3.5 navView.setupWithNavController(navController)\r\n\r\n    public static void setupWithNavController(@NonNull final NavigationView navigationView,\r\n                @NonNull final NavController navController) {\r\n            navigationView.setNavigationItemSelectedListener(\r\n                    new NavigationView.OnNavigationItemSelectedListener() {\r\n                        @Override\r\n                        public boolean onNavigationItemSelected(@NonNull MenuItem item) {\r\n                            //目标页面是否被选中\r\n                            boolean handled = onNavDestinationSelected(item, navController);\r\n                            if (handled) {\r\n                                //切换菜单状态、关闭抽屉\r\n                                ViewParent parent = navigationView.getParent();\r\n                                if (parent instanceof DrawerLayout) {\r\n                                    ((DrawerLayout) parent).closeDrawer(navigationView);\r\n                                } else {\r\n                                    BottomSheetBehavior bottomSheetBehavior =\r\n                                            findBottomSheetBehavior(navigationView);\r\n                                    if (bottomSheetBehavior != null) {\r\n                                        bottomSheetBehavior.setState(BottomSheetBehavior.STATE_HIDDEN);\r\n                                    }\r\n                                }\r\n                            }\r\n                            return handled;\r\n                        }\r\n                    });\r\n            final WeakReference<NavigationView> weakReference = new WeakReference<>(navigationView);\r\n            navController.addOnDestinationChangedListener(\r\n                    new NavController.OnDestinationChangedListener() {\r\n                        @Override\r\n                        public void onDestinationChanged(@NonNull NavController controller,\r\n                                @NonNull NavDestination destination, @Nullable Bundle arguments) {\r\n                            NavigationView view = weakReference.get();\r\n                            if (view == null) {\r\n                                navController.removeOnDestinationChangedListener(this);\r\n                                return;\r\n                            }\r\n                            Menu menu = view.getMenu();\r\n                            for (int h = 0, size = menu.size(); h < size; h++) {\r\n                                MenuItem item = menu.getItem(h);\r\n                                item.setChecked(matchDestination(destination, item.getItemId()));\r\n                            }\r\n                        }\r\n                    });\r\n        }\r\n    \r\n\r\n最后就是状态切换了，当点击menu菜单或者目标Fragment切换的时候，改变状态。\r\n\r\n### 3.6 遗留问题\r\n\r\n**遗留：**还记得上面说的那个在设置menu菜单栏的item的ID要和navigation.xml里fragment的ID相同么？至于为什么要这么做，我们看上面的第一段代码：跟踪**onNavDestinationSelected()：**\r\n\r\n    public static boolean onNavDestinationSelected(@NonNull MenuItem item,\r\n                @NonNull NavController navController) {\r\n           \t.......\r\n            .......\r\n            if ((item.getOrder() & Menu.CATEGORY_SECONDARY) == 0) {\r\n                builder.setPopUpTo(findStartDestination(navController.getGraph()).getId(), false);\r\n            }\r\n            NavOptions options = builder.build();\r\n            try {\r\n                //TODO provide proper API instead of using Exceptions as Control-Flow.\r\n                navController.navigate(item.getItemId(), null, options);\r\n                return true;\r\n            } catch (IllegalArgumentException e) {\r\n                return false;\r\n            }\r\n        }\r\n    \r\n\r\n我们看到最后还是调用navigate()方法,并且将MenuItem的ID作为参数传递过去：\r\n\r\n    public void navigate(@IdRes int resId, @Nullable Bundle args, @Nullable NavOptions navOptions,\r\n                @Nullable Navigator.Extras navigatorExtras) {\r\n            NavDestination currentNode = mBackStack.isEmpty()\r\n                    ? mGraph\r\n                    : mBackStack.getLast().getDestination();\r\n            if (currentNode == null) {\r\n                throw new IllegalStateException(\"no current navigation node\");\r\n            }\r\n            @IdRes int destId = resId;\r\n            ......\r\n            ......\r\n            //根据menu id查询目标页面\r\n            NavDestination node = findDestination(destId);\r\n            if (node == null) {\r\n                final String dest = NavDestination.getDisplayName(mContext, destId);\r\n                throw new IllegalArgumentException(\"navigation destination \" + dest\r\n                        + (navAction != null\r\n                        ? \" referenced from action \" + NavDestination.getDisplayName(mContext, resId)\r\n                        : \"\")\r\n                        + \" is unknown to this NavController\");\r\n            }\r\n            navigate(node, combinedArgs, navOptions, navigatorExtras);\r\n        }\r\n    \r\n\r\n`NavDestination node = findDestination(destId)`通过Menu Item的ID查询**NavDestination：**  \r\n**\r\n\r\n    @SuppressWarnings(\"WeakerAccess\") /* synthetic access */\r\n        NavDestination findDestination(@IdRes int destinationId) {\r\n            .......\r\n            return currentGraph.findNode(destinationId);\r\n        }\r\n    \r\n    @Nullable\r\n        final NavDestination findNode(@IdRes int resid, boolean searchParents) {\r\n            NavDestination destination = mNodes.get(resid);\r\n            // Search the parent for the NavDestination if it is not a child of this navigation graph\r\n            // and searchParents is true\r\n            return destination != null\r\n                    ? destination\r\n                    : searchParents && getParent() != null ? getParent().findNode(resid) : null;\r\n        }\r\n    \r\n\r\n而**mNodes**是一个SparseArrayCompat数组，而**NavDestination**中维护了navigation.xml中的每个fragment的相关信息：\r\n\r\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk3MDQ2OTM5NjEtZjc0M2Y0ZTMtNDBhOS00ZWY4LWIwODMtMTFmMWMxZWExZGRlLnBuZw#align=left&display=inline&height=383&name=image.png&originHeight=765&originWidth=1208&size=377825&status=done&width=604)\r\n\r\n在初始化的时候通过`addDestination()`放到数组mNodes中，而mId则就是我们的MenuItem的ID，所以很清楚了吧。\r\n\r\n4\\. 总结\r\n------\r\n\r\n### 4.1 流程\r\n\r\n1.  考虑到我们开始如果直接从**setupWithNavController** 入口进行分析的话，可能不太容易找到怎么创建的graph布局中的fragment，以及**NavHostFragment**到底是什么，所以我们先分析了布局中的**NavHostFragment，**我们发现为什么要在布局中声明了一个**NavHostFragment，**它是用来做什么的，最后发现在它的生命周期中创建了一个NavController，并且添加了FragmentNavigator，同时setGraph了。\r\n2.  紧接着我们通过setGraph进入到了**NavController**类中，通过graph里面设置的初始fragment看到了切换栈内切换Fragment的代码。\r\n3.  在里面我们看到了熟悉的`navigate()`方法，在里面dispatchOnDestinationChanged()吸引了我的注意力，通过查找，发现切换Fragment之后，通过该方法去改变布局的状态，也就是OnDestinationChangedListener接口。\r\n4.  到这里基本的代码实现已经了解的差不多了，然后我回到了入口，通过初始化NavController，调用NavigationUI中的方法绑定**NavigationView**、**ToolBar**、**BottomNavigationView**、**DrawerLayout**等布局，在调用`navigate()`方法后，改变状态，整个流程就走通了。\r\n\r\n> 可能有一些不合理的地方，望大家见谅，但是这是我此次的一个基本流程。\r\n\r\n### 4.2 类图\r\n\r\n[![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMjc5NTA1LzE1NTk3MjgwNzI4MDEtZTRlMGMxOTUtZTRkMy00ODdjLTk0NjktYjZlZjc0YjU0OGZjLnBuZw#align=left&display=inline&height=560&name=image.png&originHeight=1024&originWidth=1363&size=146731&status=done&width=746)](http://lc-2hxprqvs.cn-n1.lcfile.com/55a8ef5cb455ed676f77/navigation.png)\r\n\r\n### 4.3 分析\r\n\r\n#### 4.3.1 **NavHostFragment**\r\n\r\n我们在Activity的布局里面设置了**NavHostFragment**,同时设置了navGraph布局，经过上面的分析我们知道**NavHostFragment**中新建了NavController,并且创建了用来管理Fragment事务及切换的**FragmentNavigator**，可以简单的把它理解成连接Fragment和NavController的一个桥梁，同时也提供了包含导航的容器布局。\r\n\r\n#### 4.3.2 NavController\r\n\r\nNavContorller是整个导航组件的核心，通过它来加载xml中fragment节点转化成**NavDestination**，并保存在栈内，通过navigate()方法切换栈内NavDestination，以做到fragment的切换操作。同时当fragment切换后，下发**OnDestinationChanged**接口，来改变NavgationView、BottomNavgationView、Menu等相关UI操作。\r\n\r\n#### 4.3.3 NavigationUI\r\n\r\n通过NavgationUI类，为各个View设置接口监听，将View的UI状态和NavController中的切换Fragment做了绑定。\r\n\r\n> 到这里整个Navgation组件的源码分析就结束了，大概的流程已经很清晰了，当然没有做到百分百，比如Deep Link部分，感兴趣的可以自行看一下，可以按照这个思路去真的看一下源码，看完之后你真的会对Navgation组件有更深的理解。当然你也可以参考CodeLabs中的Demo以及文档，也可以看我的Jepack_Note的代码，如有不对的地方，还望指出，谅解.",
      "data": {
        "title": "[转载] 1. Jetpack源码解析---看完你就知道Navigation是什么了？",
        "date": "2019-10-07 14:14:33",
        "tags": [
          "Jetpack",
          "Navigation",
          "转载"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。\r\n\r\n本文链接：[https://blog.csdn.net/lyhhj/article/details/93757755](https://blog.csdn.net/lyhhj/article/details/93757755)\r",
      "fileName": "jetpack-navigation"
    },
    {
      "content": "### kotlin函数\r\n\r\nmain函数  \r\n\r\n    fun main(args:array<String>){\r\n        \r\n    }\r\n\r\n带参数带返回值\r\n\r\n    fun sum(a:Int,b:Int):Int{\r\n        return a+b\r\n    }\r\n    \r\n表达式做函数体，返回值类型自动推断的函数\r\n\r\n    fun sum(a:Int,b:Int)=a+b\r\n    \r\n函数无返回值\r\n    \r\n    fun sum(a:Int,b:Int){\r\n        println(\"sun is ${a+b}\")\r\n    }\r\n    \r\n变量\r\n\r\nval 只读\r\n   \r\n    val a:Int=1 //立即赋值\r\n    val b=2 //自动推断出int类型\r\n    val c:Int //类型\r\n    c=3  //明确赋值\r\n    \r\nvar 读写\r\n    \r\n    var a=5\r\n    a+=1\r\n    \r\n注释跟java一样\r\n\r\n表达式\r\n\r\n    fun sum(a:Int,b:Int):Int{\r\n        if(a>b){\r\n            return a\r\n        }else{\r\n            return b\r\n        }\r\n    }\r\n    \r\nif作为表达式\r\n\r\n    fun sum(a:Int,b:Int)=if(a>b) a else b\r\n    \r\n可空值 null检测\r\n\r\n变量的值可以为null，必须在声明处的类型后添加?标识该引用可以为空\r\n    \r\nstr的值不是数字返回null\r\n    \r\n    fun parseInt(str:String):Int?{\r\n        \r\n    }\r\n\r\n使用返回可空值的函数\r\n\r\n    fun parseInt(str:String):Int?{\r\n        return str.toIntOrNull()\r\n    }\r\n    \r\n    fun printInt(a:String,b:String){\r\n        val x=parseInt(a)\r\n        val y=parseInt(b)\r\n        \r\n        \r\n        //直接使用x y 可能会报错，因为可能为空\r\n        if(x!=null&&y!=null){\r\n            println(x*y)\r\n        }else{\r\n            println(\"error\")    \r\n        }\r\n        \r\n        //或者检测空值，x y会自动转换成非空值\r\n        if(x==null){\r\n            println(\"error\")\r\n            return\r\n        }\r\n        if(y==null){\r\n            println(\"error\")\r\n            return\r\n        }\r\n        println(x*y)\r\n    }\r\n    \r\n    \r\n使用类型检测及自动类型转换\r\n\r\nis运算符检测一个表达式是否某类型的一个实例，如果一个不可变的局部变量或属性已经判断出为某类型，检测后的分支中可以直接当作该类型使用，不需显示转换：\r\n\r\n    fun getStringLength(obj:Any):Int?{\r\n        if(obj is String){\r\n            return obj.length\r\n        }\r\n        return null\r\n    }\r\n    \r\n或者\r\n\r\n    fun getStringLength(obj:Any):Int?{\r\n            if(obj !is String){\r\n                return null\r\n            }\r\n            //自动转换为 string\r\n            return obj.length\r\n        }\r\n        \r\n    fun getStringLength(obj:Any):Int?{\r\n        if(obj is String&&obj.length>0){\r\n            return obj.length\r\n        }\r\n        return null\r\n    }\r\n    \r\n\r\nfor循环.\r\n\r\n\r\n    val list= listOf<String>(\"a\",\"b\",\"c\")\r\n    \r\n    //直接循环\r\n    for (l in list){\r\n        println(l)\r\n    }\r\n    \r\n    //根据下标找数据  \r\n    for (index in list.indices){\r\n        println(\"index ${list[index]}\")\r\n    }\r\n\r\n    //while循环  \r\n    var i=0\r\n    while (i<list.size){\r\n        println(\"while ${list[i]}\")\r\n        i++\r\n    }\r\n    \r\n\r\nwhen表达式\r\n\r\n类似java的  \r\n\r\n        switch (){\r\n            case 0:\r\n                break;\r\n        }\r\n\r\n    fun getWhen(s:String):String?{\r\n        when(s){\r\n            \"a\"-> return \"a1\"\r\n            \"b\"-> return \"b1\"\r\n            \"c\"-> return \"c1\"\r\n        }\r\n        return null\r\n    }\r\n\r\nrange 使用区间  \r\n\r\n    val x=1\r\n    val y=10\r\n    if (x in 1..y+1){\r\n        println(\"range\")\r\n    }\r\n    \r\n检测某个数字是否在区间内  \r\n\r\n    val list= arrayListOf<String>(\"a\",\"b\",\"c\")\r\n    val i=-1\r\n    if (i !in 0..list.lastIndex){\r\n        println(\"${i}\")\r\n    }\r\n    \r\n    //list.indices 指list 0..list.size-1的长度\r\n    if (list.size !in list.indices){\r\n        println(\"${list.indices}---${list.size}\")\r\n    }\r\n    \r\n    //打印 0-10的数\r\n    //包含10\r\n    for (x in 0..10){\r\n        println(x)\r\n    }\r\n    //不包含10\r\n     for (x in  0 until 10){\r\n        println(x)\r\n    }\r\n\r\n    //0-10中,顺序隔3个打印\r\n    for (x in 0..11 step 3){\r\n        println(x)\r\n    }\r\n\r\n    //倒叙隔4个排序\r\n    for (x in 11 downTo 0 step 4){\r\n        println(x)\r\n    }\r\n    \r\n循环迭代  \r\n\r\n    for (x in list){\r\n        println(x)\r\n    }\r\n    \r\n用in判断集合是否包含实例\r\n\r\n    //如果包含set就进判断，不走后续判断，类似java switch ()\r\n    val set= setOf<String>(\"aa\",\"bb\",\"cc\")\r\n    when{\r\n        \"a\" in set -> println(\"这是 a\")\r\n        \"bb\" in set -> println(\"这是 b\")\r\n        \"cc\" in set -> println(\"这是 c\")\r\n    }\r\n    \r\n用lambada过滤（filter）,映射（map）\r\n  \r\n    list.filter { it.startsWith(\"a\") }\r\n            .sortedBy { it }\r\n            .map { it.toUpperCase() }\r\n            .forEach { println(it) }\r\n\r\n\r\n创建数据类\r\n\r\n    data class UserBean(val uid:Int=0,var username:String?=null,var password:String?=null)\r\n\r\n包含  get ,  set ,   toString , equals , hashCode , copy\r\n\r\n    \r\n函数参数默认值\r\n    \r\n    fun getWhen(s:String=\"\",i:Int=0){}\r\n    \r\n过滤list\r\n\r\n    val list= arrayListOf<Int>(1,2,3,41,5,16,5,3,21,1)\r\n    //val s=list.filter { x-> x > 9 }\r\n    val s=list.filter { it>3}\r\n    for (l in s){\r\n        println(l)\r\n    }\r\n    \r\nString内插\r\n\r\n    println(\"${list.indices}---${list.size}\")\r\n    \r\n类型判断\r\n    \r\n    when(s){\r\n       is UserBean -> return \"a1\"\r\n        \"b\" -> return \"b1\"\r\n       is BaseBean<*> -> return \"c1\"\r\n    }\r\n\r\nmap 遍历map\r\n\r\n    val map= mapOf(\"a\" to \"aa\",\"b\" to \"bb\",\"c\" to \"cc\")\r\n    for ((k,v) in map){\r\n        println(\"${k}-----${v}\")\r\n    }\r\n\r\n    //打印map的value\r\n    println(map[\"a\"])\r\n    //给map赋值\r\n    var map= HashMap<String,String>()\r\n    map[\"a\"]=\"asdfas\"\r\n    println(map[\"a\"])\r\n    \r\n    \r\nlateinit 和 lazy 是 Kotlin 中的两种不同的延迟初始化的实现\r\n\r\n    lateinit 只用于变量 var，而 lazy 只用于常量 val\r\n\r\n创建单例模式\r\n\r\n    //object修改类，为单例模式\r\n    object Bean{}\r\n    \r\n用 ? 修饰代表可以为null\r\n\r\n    val file=File(\"T\").listFiles()\r\n    println(file?.size)\r\n    \r\nkotlin 类型\r\n\r\n    Double\r\n    Float\r\n    Long\r\n    Int\r\n    Short\r\n    Byte\r\n    \r\n    Long类型在后面加L：  123L\r\n    Float类型在后面加F： 123F\r\n    \r\nkotlin 1.1起\r\n使用下划线使常量易读\r\n\r\n    val a=1_000_000\r\n    val b=1_0000_0000L\r\n    val c=1_000.000_001\r\n    \r\n显式转换\r\n\r\n    //a为int,b为long类型,编译不通过需要显式转换\r\n    if (a==b)\r\n    \r\n    if (a==b.toInt()){}\r\n    \r\n    \r\n运算\r\n\r\n    位运算符只用 Int Long:\r\n    \r\n    shl(bits) -有符号左移（java的<<）\r\n    shr(bits) -有符号右移（java的>>）\r\n    ushr(bits) -无符号右移（java的>>>）\r\n    and(bits) -位与\r\n    or(bits) -位或\r\n    xor(bits) -位异或\r\n    inv() -位非\r\n    \r\n字符 char\r\n    \r\n    //char显示转换 int\r\n    val s='1'\r\n    s.toInt()\r\n\r\nBoolean\r\n\r\n    ||    或\r\n    &&    与\r\n    !     非\r\n\r\n数组\r\n    \r\n    Array\r\n    \r\n字符串\r\n    \r\n    //字符串添加转义字符\r\n    val s=\"hello\\nworld\"\r\n\r\n字符串模板\r\n\r\n    // $\r\n     val s=\"hello\\nworld\"\r\n    val sa=\"x= ${s}\"\r\n    println(sa)\r\n\r\nif 表达式\r\n\r\n    if(true){\r\n        \r\n    }elese{\r\n        \r\n    }\r\n\r\nwhen 表达式\r\n\r\n    val s=1\r\n    //when取代了switch操作符\r\n    when(s){\r\n        1 -> println(\"aa\")\r\n        //多个分支放一起，用,分隔\r\n        2,3 -> println(\"bb\")\r\n        //用表达式做条件\r\n        getInt() -> println(\"cc\")\r\n        //检测是否在区间\r\n        in 5..10 -> println(\"dd\")\r\n        //其他分支不满足进else\r\n        else ->{\r\n            println(\"else\")\r\n        }\r\n    }\r\n\r\nfor循环\r\n\r\nwhile , do while\r\n\r\n    while(s>0){\r\n\r\n    }\r\n\r\n    do{\r\n        val y=1\r\n    }while(y!=null)\r\n    \r\n返回和跳转\r\n\r\n    return: 从最直接包围他的函数或匿名函数返回\r\n    break:终止直接包围他的循环\r\n    continue:继续下一次直接包围他的循环\r\n\r\n类\r\n    \r\n    class修饰\r\n    \r\n构造函数\r\n    \r\n    //constructor主构造函数，一个或多个次构造函数  \r\n    //主构造函数有注解或可见性修饰符，不可以省略\r\n    //主构造函数可以省略，主构造函数不能包含任何代码\r\n    class Test constructor(string: String){\r\n\r\n        //初始化块代码，主构造参数可以在init中使用\r\n        init {\r\n\r\n        }\r\n    \r\n    \r\n    class Test(val string: String,age:Int) {\r\n\r\n        //初始化块代码，主构造参数可以在init中使用\r\n        init {\r\n    \r\n        }\r\n    \r\n        //次级构造函数,次级构造函数委托给主构造函数需要添加this\r\n        constructor(s: String):this(s,0)\r\n        }\r\n    }\r\n\r\n创建类的实例\r\n\r\n    //调用构造函数，kotlin没有new\r\n    val text=Test(\"a\",0)\r\n    \r\n继承\r\n    \r\n    覆盖函数\r\n    覆盖属性\r\n    覆盖规则\r\n    下次再学    \r\n    \r\n    \r\n抽象类\r\n    \r\n    abstract修饰\r\n    \r\n伴生对象\r\n\r\n\r\n属性和字段\r\n\r\n    属性用var是可变，val是只读\r\n    \r\n    class Test(var string: String?=null,var age:Int?=0) \r\n    \r\n    //用其中某个属性，用名称引用他\r\n    val text=Test()\r\n    text.age\r\n    \r\nget set\r\n\r\n幕后字段， 幕后属性，编译器常量，惰性初始化属性，覆盖属性，委托属性\r\n\r\n\r\n接口\r\n\r\n    用interface修饰\r\n    一个类或对象可以实现一个或多个接口\r\n\r\n接口中的属性\r\n解决覆盖冲突\r\n\r\n    interface A{\r\n        fun getA(){\r\n            println(\"a\")\r\n        }\r\n    }\r\n    \r\n    interface B{\r\n        fun getA(){\r\n            println(\"ba\")\r\n        }\r\n        fun getB(){\r\n            println(\"bb\")\r\n        }\r\n    }\r\n    \r\n    class C:A,B{\r\n        override fun getA() {\r\n            //TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\r\n            //指定实现哪个父类的接口\r\n            super<A>.getA()\r\n            super<B>.getA()\r\n        }\r\n    \r\n        override fun getB() {\r\n            super.getB()\r\n        }\r\n    \r\n    }\r\n\r\n可见性修饰符 \r\n    \r\n    默认是public\r\n    prublic 声明随处可见\r\n    private 声明的文件内可见，类内部可见\r\n    protected 不适用于顶层声明，和private一样+在子类中可见\r\n    internal 相同模块随处可见\r\n    \r\n构造函数\r\n\r\n    //指定类的主构造函数的可见性，必须添加显示的 constrector\r\n    \r\n    class Test private constructor(var string: String?=null,var age:Int?=0) \r\n\r\n默认所有构造函数是public\r\n\r\n局部声明\r\n\r\n    局部变量，函数和类不能有可见性修饰符\r\n\r\n模块\r\n\r\n    可见性修饰符 internal 只在相同模块内可见，一个模块是编译在一起的一套kotlin文件\r\n    一个idea模块\r\n    一个maven或者gradle项目\r\n    一次<kotlinc>Ant人物执行所编译的一套文件\r\n\r\n扩展\r\n\r\n扩展函数\r\n\r\n扩展是静态解析  \r\n    \r\n    （有空在学吧）\r\n\r\n可空接收者\r\n\r\n扩展属性\r\n\r\n伴生对象的扩展\r\n\r\n扩展的作用\r\n\r\n扩展声明为成员\r\n\r\n动机\r\n\r\n    下次学\r\n    \r\n数据类\r\n\r\n生成的类含有一个无参的构造函数，所有的属性必须指定默认值\r\n\r\n    数据类标记为 data\r\n    data class Test (var string: String?=null,var age:Int?=0) \r\n    \r\n复制    \r\n\r\n复制一个对象改变一些属性，保持其他属性不变\r\n    \r\n    var text=Test()\r\n    text.string=\"as\"\r\n    text.age=11\r\n    text=text.copy(age = 14)\r\n    println(text.toString())\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "kotlin基础",
        "date": "2019-09-27 13:17:32",
        "tags": [
          "kotlin"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "kotlin-ji-chu"
    },
    {
      "content": "# svn,git下载地址  \r\n```\r\n链接：https://pan.baidu.com/s/1C6hn1S-hBzdduEoIm7-4XA \r\n提取码：xktl \r\n```\r\n\r\n# SVN\r\n## svn安装需注意安装 command line功能\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568588046.png)\r\n\r\n\r\n在studio的File > Settings > Version Control > Subversion 添加svn路径\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568609300.png)\r\n\r\n\r\n\r\n# GIT\r\n在studio的File > Settings > Version Control > Git 添加git路径，Test测试git版本\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568633842.png)\r\n\r\n\r\nGitHub直接输入账号密码即可\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568657529.png)\r\n\r\n\r\n## androidstudio 看不到svn的工具小图标\r\n\r\n先看androidstudio是否安装svn\r\nFile > Settings > Plugins 搜索Subversion Integration\r\n\r\n如果有Subversion Integration 则安装好svn工具；如果没有安装，则进行安装。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569568783281.png)\r\n\r\n\r\n再选择Subversion即可",
      "data": {
        "title": "Android Studio 配置SVN，GIT",
        "date": "2019-09-24 17:56:27",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "android-studio-pei-zhi-svngit"
    },
    {
      "content": "## 1.设置编辑界面和代码主题\r\n\r\nFile > Settings > Appearance & Behavior > Appearance > Theme\"，默认可以选择Light和Darcula，分别为白色和黑色主题，选择之后点击Apply应用。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570829889.png)\r\n\r\n\r\n## 2.修改字体大小和字体样式\r\nFile > Settings > Editor > Color Scheme > Color Scheme Font，先选择一个Scheme主题，打勾设置size然后Apply就好了。在Font下可以选择各种字体。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570855113.png)\r\n\r\n\r\n## 3.设置文件注释模板\r\nFile > Settings > Editor > File and Code Templates，切换到Includes下，在File Header里面设置注释模板。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570879010.png)\r\n\r\n\r\n## 4.默认文件编码\r\n\r\nFile > Settings > Editor > File Encodings。建议将 IDE Encoding 、 Project Encoding 、 Properties Fiels 都设置成统一的UTB-8编码。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570937484.png)\r\n\r\n\r\n## 5.显示行号\r\nFile | Settings | Editor | General | Appearance，勾选show line numbers\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570972769.png)\r\n\r\n\r\n## 6.自动导入\r\nFile > Settings > Editor > General > Auto Import,修改不区分大小写提示，勾选导包和删除无用包\r\n\r\n![](https://ouluqiang.github.io//post-images/1569570998987.png)\r\n\r\n\r\n## 鼠标悬停显示方法说明\r\nFile > Settings > Editor > General\r\n可修改悬停多久，才显示方法说明(单位：毫秒)。\r\n\r\n![](https://ouluqiang.github.io//post-images/1569571044992.png)\r\n\r\n\r\n\r\n## 删除的类的历史记录，与未修改前的类对比\r\n\r\n![](https://ouluqiang.github.io//post-images/1569572112977.png)\r\n\r\n\r\n## 导出，导入studio设置属性\r\nFile > Export Settings 导出设置\r\n\r\n![](https://ouluqiang.github.io//post-images/1569572137353.png)\r\n\r\n\r\nFile > Import Settings 导入设置\r\n\r\n![](https://ouluqiang.github.io//post-images/1569572165039.png)\r\n",
      "data": {
        "title": "Android Studio常用设置",
        "date": "2019-09-24 17:19:41",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "android-studio-chang-yong-she-zhi"
    },
    {
      "content": "# 下载\r\n\r\n[jdk下载地址](https://www.oracle.com/technetwork/java/javase/downloads/index.html)\r\n\r\njdk下载  \r\n```\r\n链接：https://pan.baidu.com/s/1AVshFeP9ZkT05xk_FIINag \r\n提取码：t8ci \r\n```\r\n\r\n\r\n[Android studio sdk 下载地址](http://www.android-studio.org/index.php)\r\n\r\n## jdk12\r\n\r\n安装JDK11或以上版本，安装过程中没有提示安装JRE，进入JDK安装路径下 shift+右键 在此处打开命令窗口\r\n\r\n  输入  \r\n  ```\r\n   bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre   \r\n  ```\r\n  执行完成就会生成JRE\r\n  \r\n![](https://ouluqiang.github.io//post-images/1569573855494.png)\r\n\r\n\r\n## jdk8\r\n正常安装\r\n\r\n## 环境变量配置\r\n\r\n我的电脑右键，点击属性，点击高级系统设置，点击环境变量\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573876482.png)\r\n\r\n\r\n新建系统变量，变量名写 JAVA_HOME 变量值 填写你JDK安装的路径\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573893452.png)\r\n\r\n\r\n双击系统变量path编辑变量值 %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573915023.png)\r\n\r\n\r\n在系统变量中新建 classpath 变量名，变量值为  %JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573938408.png)\r\n\r\n\r\nwin+R运行输入cmd，输入java -version查看JDK版本和JVM信息\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573946973.png)\r\n\r\n\r\n\r\n# sdk\r\n\r\n新建系统变量ANDROID_HOME，变量值D:\\xx\\sdk（以你安装目录为准,确认里面有tools和add-ons等多个文件夹）\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573974734.png)\r\n\r\n\r\n在系统变量PATH后面加上变量值;%ANDROID_HOME%\\platform-tools;\r\n\r\n![](https://ouluqiang.github.io//post-images/1569573987528.png)\r\n\r\n\r\nwin+R运行输入cmd，输入adb 查看\r\n\r\n![](https://ouluqiang.github.io//post-images/1569574016688.png)\r\n",
      "data": {
        "title": "jdk sdk环境配置 Android下载",
        "date": "2019-09-24 17:16:07",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jdk-sdk-huan-jing-pei-zhi-android-xia-zai"
    },
    {
      "content": "## type封装获取泛型的实际类型\r\n    \r\n> 通过getGenericSuperclass方法可以获取当前对象的直接超类的 Type\r\n    \r\ngetClass().getGenericSuperclass()返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type  \r\n然后将其转换ParameterizedType。。  \r\ngetActualTypeArguments()返回表示此类型实际类型参数的 Type 对象的数组。  \r\n[0]就是这个数组中第一个了。。简而言之就是获得超类的泛型参数的实际类型。。\r\n```\r\n        Type genericSuperclass = getClass().getGenericSuperclass();\r\n        if (genericSuperclass instanceof ParameterizedType) {\r\n            this.type = ((ParameterizedType) genericSuperclass).getActualTypeArguments()[0];\r\n        } else {\r\n            this.type = Object.class; \r\n            // 基本不会走这个判断\r\n        }\r\n```     \r\n        \r\n        \r\n## 解决 gson反序列化自动将int类型转化成double类型\r\n```\r\n    private static Gson gson=new GsonBuilder().\r\n        registerTypeAdapter(Double.class, new JsonSerializer<Double>() {\r\n\r\n            @Override\r\n            public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) {\r\n                if (src == src.longValue())\r\n                    return new JsonPrimitive(src.longValue());\r\n                return new JsonPrimitive(src);\r\n            }\r\n        }).create();\r\n```",
      "data": {
        "title": "gson type封装泛型",
        "date": "2019-09-24 16:33:44",
        "tags": [
          "Android",
          "gson"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gson-type-feng-zhuang-fan-xing"
    },
    {
      "content": "## 创建分支\r\n在GitHub的博客项目中新建一个分支\r\n\r\n![](https://ouluqiang.github.io//post-images/1569311927040.jpg)\r\n\r\n克隆项目到本地  \r\n```\r\ngit clone https://github.com/xxx/xxx.github.io.git\r\n```\r\n\r\n## 切换分支\r\n\r\n到本地项目中打开Git Bash, 切换到项目分支，查看分支，用 git checkout XXX 切换分支\r\n```\r\n# 列出所有本地分支\r\n$ git branch\r\n\r\n# 列出所有远程分支\r\n$ git branch -r\r\n\r\n# 列出所有本地分支和远程分支\r\n$ git branch -a\r\n\r\n# 切换到指定分支，并更新工作区\r\n$ git checkout [branch-name]\r\n```\r\n![](https://ouluqiang.github.io//post-images/1569311864422.jpg)\r\n\r\n\r\n把源文件复制到分支项目,再打开Git Bash 提交代码\r\n![](https://ouluqiang.github.io//post-images/1569311872576.jpg)\r\n\r\n\r\n```\r\n# 添加当前目录的所有文件到暂存区\r\n$ git add .\r\n\r\n# 提交暂存区到仓库区\r\n$ git commit -m ‘修改说明，随便写’\r\n\r\n# 提交到远程仓库\r\ngit push\r\n```\r\n\r\n提交成功\r\n![](https://ouluqiang.github.io//post-images/1569311915447.jpg)\r\n\r\n\r\n但是提交完会因为提交的源文件有token，GitHub会给你发邮件token泄漏，将原先生成的token移除，原先的token已经失效了，你需要重新申请token,在Gridea的配置修改token,后续如果要提交源文件有1种方法就是不提交有token的文件，也就是源文件/config/setting.json，不提交这个文件就即可\r\n\r\n\r\n<!-- ## 生成ssh-key的私钥和公钥\r\n生成key,看C盘用户目录SSH\r\n\r\n```\r\nssh-keygen -t rsa      //一路回车下来\r\n```\r\n![](https://ouluqiang.github.io//post-images/1569314857492.jpg)\r\n\r\n测试是否能连接上GitHub服务器\r\n```\r\nssh -T git@github.com\r\n```\r\n输出是.........\r\nPermission denied (publickey).\r\n需要将上面生成的public key(id_rsa.pub文件内容)拷贝到github服务器的SSH Keys中，\r\n再.ssh目录下打开终端输入下面代码查看内容，或者直接记事本打开查看\r\n\r\n```\r\ncat id_rsa.pub\r\n```\r\n\r\n![](https://ouluqiang.github.io//post-images/1569315446419.jpg)\r\n\r\n头像 > settings > ssh\r\n![](https://ouluqiang.github.io//post-images/1569315521381.jpg)\r\n\r\n再测试下是否连接GitHub服务器 ssh -T git@github.com 能显示GitHub用户名就表示连接成功\r\n![](https://ouluqiang.github.io//post-images/1569315793106.jpg) -->\r\n",
      "data": {
        "title": "Gridea保存源文件",
        "date": "2019-09-24 15:55:55",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gridea-bao-cun-yuan-wen-jian"
    },
    {
      "content": "Android常用的开发工具\r\n<!-- more -->\r\n\r\n## Android stido，sdk，jdk\r\n[jdk下载地址](https://www.oracle.com/technetwork/java/javase/downloads/index.html)\r\n\r\njdk下载  \r\n```\r\n链接：https://pan.baidu.com/s/1AVshFeP9ZkT05xk_FIINag \r\n提取码：t8ci \r\n```\r\n\r\n\r\n[Android studio sdk 下载地址](http://www.android-studio.org/index.php)\r\n\r\n[Android studio sdk 下载地址](https://developer.android.google.cn/studio)\r\n\r\n## svn,git下载地址\r\n[git下载](https://git-scm.com/downloads)\r\n\r\n```\r\n链接：https://pan.baidu.com/s/1C6hn1S-hBzdduEoIm7-4XA \r\n提取码：xktl \r\n```\r\n\r\n## 抓包工具charles学习版\r\n```\r\n链接：https://pan.baidu.com/s/1aDRIDVu9y66niOZOnPcMDQ \r\n提取码：sj13 \r\n```\r\n\r\n## sqlite数据库工具\r\n```\r\n链接：https://pan.baidu.com/s/1I_w-rARDcKocKBXGOMbJdg \r\n提取码：trl1\r\n```\r\n\r\n## 颜色获取\r\n```\r\n链接：https://pan.baidu.com/s/1-sLi9-PVYksCiE-RHSXquw \r\n提取码：tyrw \r\n```\r\n\r\n## 获取SHA1值\r\n```\r\n链接：https://pan.baidu.com/s/15AvGDv-WjzU7jvLhJeLvhg \r\n提取码：081p \r\n```\r\n\r\n\r\n# idea 学习版\r\nhttp://idea.toocruel.net",
      "data": {
        "title": "常用开发工具",
        "date": "2019-09-24 13:22:26",
        "tags": [
          "工具"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "Android常用的开发工具\r",
      "fileName": "chang-yong-kai-fa-gong-ju"
    },
    {
      "content": "charles基本设置使用\r\n\r\n<!-- more -->\r\n\r\n\r\n## 抓包工具charles学习版\r\n```\r\n链接：https://pan.baidu.com/s/1aDRIDVu9y66niOZOnPcMDQ \r\n提取码：sj13 \r\n```\r\n\r\n## http抓包\r\n代理 > 代理设置中设置端口号 8888 ,勾选启用HTTP代理\r\n![代理设置](https://ouluqiang.github.io//post-images/1569304039210.jpg)\r\n\r\n![端口](https://ouluqiang.github.io//post-images/1569303949066.jpg)\r\n\r\n帮助 > 本地ip 查看电脑ip\r\n![帮助](https://ouluqiang.github.io//post-images/1569304145156.jpg)\r\n\r\n![ip](https://ouluqiang.github.io//post-images/1569304186481.jpg)\r\n\r\n手机和电脑在一个网段(连接同一个路由器)，在手机网络设置里面填写代理服务地址信息\r\n电脑ip ,  端口号\r\n\r\n![代理](https://ouluqiang.github.io//post-images/1569304740083.jpg)\r\n\r\n在使用手机进行网络请求时，charles会有一个提示，允许即可\r\n\r\n## https抓包\r\nhttps需要安装证书，注意电脑安装证书需要安装到受信任的颁发机构\r\n\r\n![证书](https://ouluqiang.github.io//post-images/1569305139356.jpg)\r\n\r\n![安装证书](https://ouluqiang.github.io//post-images/1569305350226.jpg)\r\n\r\n手机也需要安装证书，在浏览器下载证书,如果不识别，不能安装，建议用谷歌浏览器app下载安装\r\n```\r\nchls.pro/ssl\r\n```\r\n![手机证书](https://ouluqiang.github.io//post-images/1569305456616.jpg)\r\n\r\n勾选Windows代理，打开ssl代理设置\r\n![ssl设置](https://ouluqiang.github.io//post-images/1569305597175.jpg)\r\n\r\n添加主机和端口号， 主机用*，端口号443抓取https，也可以用*\r\n![](https://ouluqiang.github.io//post-images/1569305786428.jpg)\r\n\r\n## Android 7.0抓https失败的解决方案\r\n\r\n新建network_security_config.xml文件\r\n![network_security_config](https://ouluqiang.github.io//post-images/1569302838764.png)\r\n\r\n在network_security_config.xml文件写入以下代码\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<network-security-config>\r\n    <base-config cleartextTrafficPermitted=\"true\">\r\n        <trust-anchors>\r\n            <certificates src=\"system\" overridePins=\"true\" />\r\n            <certificates src=\"user\" overridePins=\"true\" />\r\n        </trust-anchors>\r\n    </base-config>\r\n</network-security-config>\r\n```\r\n\r\n在AndroidManifest.xml添加配置  \r\n\r\n![networkSecurityConfig](https://ouluqiang.github.io//post-images/1569302899586.png)\r\n\r\n\r\n```\r\nandroid:networkSecurityConfig=\"@xml/network_security_config\"\r\n```",
      "data": {
        "title": "charles使用",
        "date": "2019-09-23 18:38:43",
        "tags": [
          "工具",
          "Charles"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "charles基本设置使用\r",
      "fileName": "charles-shi-yong"
    },
    {
      "content": "一些常用正则表达式 \r\n\r\n<!-- more -->\r\n\r\n## 正则判断函数\r\n```\r\nPattern.matches(regex, pass);\r\n```\r\n\r\n## 搜索中文\r\n```\r\n^((?!(\\*|//)).)+[\\u4e00-\\u9fa5]\r\n```\r\n\r\n## 验证密码首位为字母或数字\r\n```\r\n[0-9 a-z A-Z]\\w*\r\n```\r\n\r\n## 验证Email\r\n```\r\n\\w+@\\w+\\.[a-z]+(\\.[a-z]+)?\r\n```\r\n\r\n## 验证身份证号码\r\n```\r\n(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)\r\n```\r\n\r\n## 验证手机号码\r\n```\r\n(\\+\\d+)?1[3456789]\\d{9}$\r\n```\r\n\r\n## 验证固定电话号码\r\n```\r\n(\\+\\d+)?(\\d{3,4}\\-?)?\\d{7,8}$\r\n```\r\n\r\n## 验证整数（正整数和负整数）\r\n```\r\n\\-?[1-9]\\d+\r\n```\r\n\r\n## 验证整数和浮点数（正负整数和正负浮点数）\r\n```\r\n\\-?[1-9]\\d+(\\.\\d+)?\r\n```\r\n\r\n## 验证空白字符\r\n```\r\n\\\\s+\r\n```\r\n\r\n## 验证中文\r\n```\r\n^[\\u4E00-\\u9FA5]+$\r\n```\r\n\r\n## 验证日期（年月日）\r\n```\r\n[1-9]{4}([-./])\\d{1,2}\\1\\d{1,2}\r\n```\r\n\r\n## 验证URL地址\r\n```\r\n(https?://(w{3}\\.)?)?\\w+\\.\\w+(\\.[a-zA-Z]+)*(:\\d{1,5})?(/\\w*)*(\\??(.+=.*)?(&.+=.*)?)?\r\n```\r\n\r\n## 获取网址 URL 的一级域名\r\n```\r\n(?<=http://|\\.)[^.]*?\\.(com|cn|net|org|biz|info|cc|tv)\r\n```\r\n\r\n## 匹配中国邮政编码\r\n```\r\n[1-9]\\d{5}\r\n```\r\n\r\n## 匹配IP地址(简单匹配，格式，如：192.168.1.1，127.0.0.1，没有匹配IP段的大小)\r\n```\r\n[1-9](\\d{1,2})?\\.(0|([1-9](\\d{1,2})?))\\.(0|([1-9](\\d{1,2})?))\\.(0|([1-9](\\d{1,2})?))\r\n```\r\n\r\n",
      "data": {
        "title": "正则表达式",
        "date": "2019-09-23 18:29:08",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "一些常用正则表达式 \r",
      "fileName": "zheng-ze-biao-da-shi"
    },
    {
      "content": "写博客的工具与GitHub的基本配置\n\n<!-- more -->\n\n## 创建github 博客项目\n\n创建一个repo，名称为 yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下：\n\n![创建项目](https://ouluqiang.github.io//post-images/1569307197693.jpg)\n\n\nxxx.github.io  xxx必须是你的用户名，创建项目，我的已经存在了\n\n![](https://ouluqiang.github.io//post-images/1569307241793.jpg)\n\n\n\n\n## [创建一个 Token](https://github.com/settings/tokens/new)\n\n只勾选repo即可，防止token泄漏\n\n![](https://ouluqiang.github.io//post-images/1569307352985.png)\n\n拿到token填写到gridea的基础配置token里\n\n![](https://ouluqiang.github.io//post-images/1569307358531.png)\n\n![](https://ouluqiang.github.io//post-images/1569307416363.png)\n\n检测远程连接成功就可以了，如果确定都填对了，就关闭gridea软件再打开软件检测远程连接\n\n## [创建一个 OAuth](https://github.com/settings/applications/new)\n\n![](https://ouluqiang.github.io//post-images/1569307480431.png)\n\n填写到Gridea的配置评论栏中\n\n![](https://ouluqiang.github.io//post-images/1569307505346.png)\n\n![](https://ouluqiang.github.io//post-images/1569307563455.png)\n\n\n再博客中测试评论，成功即可",
      "data": {
        "title": "Gridea，GitHub配置使用",
        "date": "2019-09-18 18:17:55",
        "tags": [
          "blog"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "写博客的工具与GitHub的基本配置",
      "fileName": "grideagithub-pei-zhi-shi-yong"
    },
    {
      "content": "## 连接手机和电脑\n命令行 adb devices 查看连接\n\n![连接](https://ouluqiang.github.io//post-images/1568884026016.png)\n\n   \n## 设置5555端口\n设置wifi调试端口 5555\n```\n    adb tcpip 5555\n```\n\n![端口](https://ouluqiang.github.io//post-images/1568886196625.png)\n\n  \n## 查看手机ip\n```\n    adb shell  ifconfig wlan0\n```\n\n![ip](https://ouluqiang.github.io//post-images/1568886240609.png)\n\n \n手机操作，打开 设置-WLAN-配置 页面，可看到当前 IP\n\n![ip](https://ouluqiang.github.io//post-images/1568886275147.png)\n\n\n## 连接手机 \n```\n    adb connect <手机ip地址>\n```\n\n![连接](https://ouluqiang.github.io//post-images/1568886318164.png)\n\n\n\n## 成功\n连接成功显示\n\n![成功](https://ouluqiang.github.io//post-images/1568886341285.png)\n\n    \n 锤子手机测试失败",
      "data": {
        "title": "adb wifi 调试",
        "date": "2019-09-18 16:48:35",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "adb-wifi-diao-shi"
    },
    {
      "content": "## 新建代码库\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n## 配置\n```\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n## 代码提交\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n## 分支\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n## 标签\n```\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n## 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的代码差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n# 从本地master拉取代码更新当前分支：branch 一般为master\n$ git rebase [branch]\n```\n\n## 远程同步\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n## 撤销\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n## 其他\n```\n# 生成一个可供发布的压缩包\n$ git archive\n```",
      "data": {
        "title": "git命令",
        "date": "2019-09-18 16:28:33",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "git-ming-ling"
    },
    {
      "content": "[简明版教程](http://note.youdao.com/iyoudao/?p=2411)  \n[进阶版教程](http://note.youdao.com/iyoudao/?p=2445)\n## 标题  \n\n**标题，只需要在这段文字前面加上 #，再在 # 后加一个空格  \n增加一个 # ，标题字号相应降低一级**\n![标题](https://ouluqiang.github.io//post-images/1569307892987.png)\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n```\n![标题效果](https://ouluqiang.github.io//post-images/1569307931761.png)\n\n## 列表  \n\n### 无序列表  \n\n**你只需要在文字前面加上 - 就可以了；如果你希望是有序列表，在文字前面加上 1. 2. 3. 即可。**\n![无序列表](https://ouluqiang.github.io//post-images/1569307967486.png)\n\n\n```\n- 列表1\n  - 列表1.1\n  - 列表1.2\n- 列表2\n- 列表3\n```\n\n- 列表1\n  - 列表1.1\n  - 列表1.2\n- 列表2\n- 列表3\n\n\n### 有序列表\n\n![有序列表](https://ouluqiang.github.io//post-images/1569308007512.png)\n\n\n```\n1. 列表1\n    1. 列表1.1\n    2. 列表1.2\n2. 列表2\n3. 列表3\n```\n\n1. 列表1\n    1. 列表1.1\n    2. 列表1.2\n2. 列表2\n3. 列表3\n\n\n\n## 引用\n**如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。  \n在引用文字前加上 > 并与文字保留一个字符的空格**\n\n![引用](https://ouluqiang.github.io//post-images/1569308041174.png)\n\n```\n\t> 记录，成为更好的自己。--有道云笔记 \n```\n\n> 记录，成为更好的自己。--有道云笔记 \n\n\n\n\n## 粗体和斜体\n\n**用两个 * 包含一段文本就是粗体的语法；**    \n**用一个 * 包含一段文本就是斜体的语法。**  \n***注意：字符与文本之间无须空格***\n\n![斜体](https://ouluqiang.github.io//post-images/1569308084185.png)\n\n```\n*这是斜体*\n```\n\n*这是斜体*\n\n![粗体](https://ouluqiang.github.io//post-images/1569308112324.png)\n\n```\n**这是粗体**\n```\n\n**这是粗体**\n\n\n## 链接与图片\n\n**链接：在 Markdown 中，插入链接只需要使用 [显示文本] (链接地址) 即可。**  \n**图片：在 Markdown 中，插入图片只需要使用 ![显示文本] (图片链接地址)即可。**  \n***注：插入图片的语法和链接的语法很像，只是前面多了一个！***  \n\n![链接](https://ouluqiang.github.io//post-images/1569308139421.png)\n\n```\n[链接](https://ouluqiang.github.io)\n```\n\n[链接](https://ouluqiang.github.io)\n\n![图片](https://ouluqiang.github.io//post-images/1569308339148.png)\n\n```\n![图片连接演示](https://ouluqiang.github.io//images/avatar.png?v=1569307577738)\n```\n\n![图片连接演示](https://ouluqiang.github.io//images/avatar.png?v=1569307577738)\n\n\n## 分割线\n\n**只需要另起一行，连续输入三个星号** ***  **即可分割两段文字内容。**\n\n```\n\t第一段\n\t***\n\t第二段\n\n\t第一段\n\t---\n\t第二段\n```\n\n第一段\n***\n第二段\n\n第一段\n---\n第二段\n\n\n\n\n## 代码高亮\n\n![代码高亮](https://ouluqiang.github.io//post-images/1569308458877.png)\n\n![代码高亮代码](https://ouluqiang.github.io//post-images/1569308483292.png)\n\n```\n代码高亮\n```\n\n## 制作待办事项To-do List\n你只需要在待办的事项文本或者清单文本前加上- [ ]、- [x]即可。\n\n**- [] 表示未完成，- [x] 表示已完成。**\n\n***注：键入字符与字符之间都要保留一个字符的空格。***\n\n![已完成](https://ouluqiang.github.io//post-images/1569308519075.png)\n\n```\n- [x] 已完成\n  - [x] 已完成\n  - [x] 已完成  \n```\n\n- [x] 已完成\n  - [x] 已完成\n  - [x] 已完成  \n\n![未完成](https://ouluqiang.github.io//post-images/1569308546303.png)\n\n```\n- [ ] 未完成\n- [ ] 未完成\n```\n\n- [ ] 未完成\n- [ ] 未完成\n\n## 高效绘制 流程图、序列图、甘特图、表格\n### 流程图\n书写graph XX，用以确定将要绘制的流程图及其类型（XX表示流程图类型）。\n流程图分为竖向和横向两大类，竖向包括自上而下和自下而上两种顺序，横向包括从右到左和从左到右两种顺序。  \n其对应语法分别为：graph TB/graph BT/graph RL/graph LR。\n\nTB - top bottom（自上而下）  \nBT - bottom top（自下而上）  \nRL - right left（从右到左）  \nLR - left right（从左到右）  \n\n![流程图](https://ouluqiang.github.io//post-images/1569308580136.png)\n\n![流程图效果](https://ouluqiang.github.io//post-images/1569308601497.png)\n\n\n\n```\ngraph TD\nA[直角四边形]---B{菱形}\nB --> C((圆形))\nC --> D\nC --> E\nC -->|插入文本|F\n```\n\n### 序列图\n\n![序列图](https://ouluqiang.github.io//post-images/1569308625091.png)\n\n![序列图效果](https://ouluqiang.github.io//post-images/1569308658344.png)\n\n\n```\nsequenceDiagram\nloop every day\n    A->>B: How are you?\n\n    B->>A: Great!\nend\n```\n\n### 甘特图\n书写 gantt ，用以确定将要绘制的是甘特图。\ndateFormat YYYY-MM-DD规定了时间轴，title （标题文本）表示甘特图标题。\n需键入section，空一个字符，再输入项目名称的文本（一个section和另一个section之间要空行）。\n\n![甘特图](https://ouluqiang.github.io//post-images/1569308684380.png)\n\n![甘特图效果](https://ouluqiang.github.io//post-images/1569308707886.png)\n\n\n```\ngantt\ndateFormat YYYY-MM-DD\ntitle 产品计划书\nsection 初期阶段\n明确需求: 2018-07-01, 9d\nsection 中期阶段\n跟进开发: 2018-07-11, 9d\nsection 后期阶段\n走查测试: 2018-07-22, 9d\n```\n\n### 表格\n\n![表格](https://ouluqiang.github.io//post-images/1569308736274.png)\n\n\n```\n    header 1    | header 2    | 第三\n    ---         |---          | ---\n    row 1 col 1 | row 1 col 2 | 第三个 \n    row 2 col 1 | row 2 col 2 | 第三个\n```\n\nheader 1    | header 2    | 第三\n---         |---          | ---\nrow 1 col 1 | row 1 col 2 | 第三个 \nrow 2 col 1 | row 2 col 2 | 第三个\n\n\n## 书写数学公式\n\n![公式](https://ouluqiang.github.io//post-images/1569308765985.png)\n\n![公式图](https://ouluqiang.github.io//post-images/1569308783976.png)\n\n```math\nE = mc^2\n```\n\n\n\n",
      "data": {
        "title": "markdown编辑器教程",
        "date": "2019-08-09 17:51:21",
        "tags": [
          "Blog",
          "markdown"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/markdown-bian-ji-qi-jiao-cheng.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "markdown-bian-ji-qi-jiao-cheng"
    },
    {
      "content": "这是关于的页面，可以在这里向世界介绍你！\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": null,
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](http://hvenotes.fehey.com/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **𝖶𝗂𝗇𝖽𝗈𝗐𝗌** 或 **𝖬𝖺𝖼𝖮𝖲** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/hello-gridea.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "name": "Jetpack",
      "slug": "0ERq-Hwpp",
      "used": true
    },
    {
      "name": "Navigation",
      "slug": "TMwFKtlviY",
      "used": true
    },
    {
      "name": "转载",
      "slug": "Bvven-3pQW",
      "used": true
    },
    {
      "name": "kotlin",
      "slug": "oC2Angq_X",
      "used": true
    },
    {
      "index": -1,
      "name": "Android",
      "slug": "uPl9IEkHz",
      "used": true
    },
    {
      "name": "gson",
      "slug": "13AEsKm6N",
      "used": true
    },
    {
      "name": "markdown",
      "slug": "EYP-kC9od",
      "used": true
    },
    {
      "name": "blog",
      "slug": "FO3QcY1pj",
      "used": true
    },
    {
      "name": "Charles",
      "slug": "QXrdbuOAc",
      "used": true
    },
    {
      "name": "工具",
      "slug": "7Y0nywv1q",
      "used": true
    },
    {
      "index": -1,
      "name": "Blog",
      "slug": "wowhDkgzJ",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "ea4LAVIav",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}